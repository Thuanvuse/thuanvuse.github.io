import sys
import threading
import time
import requests
import random
import hashlib
import json
import concurrent.futures
import re
import traceback
import string
import base64
from datetime import datetime
from pathlib import Path
from PyQt6.QtWidgets import (
	QApplication, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QTableWidget, QTableWidgetItem, QComboBox, QSpinBox, QStackedWidget, QHeaderView, QInputDialog, QDialog, QTextEdit, QDialogButtonBox, QLineEdit, QMenu, QMessageBox
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer, QDate
from PyQt6.QtGui import QBrush, QColor
from faker import Faker
from unidecode import unidecode
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Random import get_random_bytes
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
import subprocess
import os
import requests



# ===================== TI·ªÜN √çCH D√ôNG CHUNG =====================
def create_proxy(proxy_string):
	parts = proxy_string.split(":")
	if len(parts) != 4:
		raise ValueError("Proxy string ph·∫£i c√≥ d·∫°ng ip:port:user:pass")
	ip, port, username, password = parts
	proxy_url = f"http://{username}:{password}@{ip}:{port}"
	return {"http": proxy_url, "https": proxy_url}

def md5_hash(text):
	return hashlib.md5(text.encode('utf-8')).hexdigest()

def make_headers(base=None, **kwargs):
	headers = base.copy() if base else {}
	headers.update(kwargs)
	return headers

from qtpy.QtWidgets import (
	QDialog, QVBoxLayout, QLabel, QLineEdit, QPushButton, QWidget, QTabWidget, QFormLayout
)
from qtpy.QtGui import QFont
from qtpy.QtCore import Qt

class GameInputDialog(QDialog):
	def __init__(self, game_list,Thuan,s1,s2 ,parent=None):
		super().__init__(parent)
		self.setWindowTitle(Thuan)
		self.setStyleSheet("""
			QDialog {
				background-color: #1f1f2e;
				color: white;
				font-family: Arial;
				font-size: 14px;
			}
			QLabel {
				color: orange;
				font-weight: bold;
			}
			QLineEdit {
				padding: 8px;
				border: 1px solid #555;
				border-radius: 5px;
				background-color: #2b2b3d;
				color: white;
			}
			QPushButton {
				background-color: orange;
				padding: 10px;
				border: none;
				border-radius: 5px;
				font-weight: bold;
				color: black;
			}
			QPushButton:hover {
				background-color: #ffaa00;
			}
			QTabWidget::pane {
				border: none;
			}
			QTabBar::tab {
				background: #2b2b3d;
				color: white;
				padding: 8px 20px;
				border-top-left-radius: 5px;
				border-top-right-radius: 5px;
			}
			QTabBar::tab:selected {
				background: orange;
				color: black;
			}
		""")

		self.selected_game = None
		self.game_account = ""
		self.game_phone = ""

		main_layout = QVBoxLayout()

		self.tab_widget = QTabWidget()
		self.tab_data = {}  # tab index -> game data

		for game in game_list:
			tab = QWidget()
			layout = QFormLayout()
			layout.setLabelAlignment(Qt.AlignLeft)
			layout.setFormAlignment(Qt.AlignTop)

			account_input = QLineEdit()
			phone_input = QLineEdit()

			layout.addRow(s1, account_input)
			layout.addRow(s2, phone_input)

			tab.setLayout(layout)
			self.tab_widget.addTab(tab, game['websiteName'])
			self.tab_data[self.tab_widget.count() - 1] = {
				"game": game,
				"account_input": account_input,
				"phone_input": phone_input
			}

		main_layout.addWidget(self.tab_widget)

		self.btn = QPushButton("Li√™n k·∫øt")
		self.btn.clicked.connect(self.accept)
		main_layout.addWidget(self.btn)

		self.setLayout(main_layout)
		self.resize(400, 300)

	def accept(self):
		index = self.tab_widget.currentIndex()
		data = self.tab_data.get(index)
		if data:
			self.selected_game = data["game"]
			self.game_account = data["account_input"].text()
			self.game_phone = data["phone_input"].text()
		super().accept()


class PingThread(QThread):
	ping_result = pyqtSignal(str, str)

	def __init__(self, address):
		super().__init__()
		self.address = address

	def run(self):
		phan_hoi = subprocess.run(["ping", "-n", "4", self.address], capture_output=True, text=True)
		if "Reply from" in phan_hoi.stdout:
			lines = phan_hoi.stdout.splitlines()
			for line in lines:
				if "time=" in line:
					time_ms = int(line.split("time=")[-1].split("ms")[0])
					if time_ms < 50:
						status = "M·∫°ng r·∫•t kh·ªèe ‚úÖ"
					elif time_ms < 100:
						status = "M·∫°ng ·ªïn ƒë·ªãnh üëç"
					elif time_ms < 200:
						status = "M·∫°ng trung b√¨nh ‚ö†Ô∏è"
					else:
						status = "M·∫°ng y·∫øu üö®"
					self.ping_result.emit(f"Ping: {time_ms} ms", status)
		else:
			self.ping_result.emit("Kh√¥ng kh·∫£ d·ª•ng", "‚ùå")
class ProxyCheckWorker(QThread):
	result_signal = pyqtSignal(int, str, bool)  # i, status, is_live

	def __init__(self, accounts, parent=None):
		super().__init__(parent)
		self.accounts = accounts

	def run(self):
		from concurrent.futures import ThreadPoolExecutor, as_completed

		def check_single_proxy(i, acc):
			proxy_str = acc[1]
			status = "‚ùå [DIE]"
			for attempt in range(3):
				try:
					proxies = create_proxy(proxy_str)
					r = requests.get("https://geo.myip.link/", proxies=proxies, timeout=5)
					ip_info = r.json()
					status = f"‚úÖ [LIVE] {ip_info['ip']} - {ip_info['country']} ({ip_info['city']})"
					return i, status, True
				except:
					continue
			return i, status, False

		with ThreadPoolExecutor(max_workers=10) as executor:
			futures = [executor.submit(check_single_proxy, i, acc) for i, acc in enumerate(self.accounts)]

			for future in as_completed(futures):
				i, status, is_live = future.result()
				self.result_signal.emit(i, status, is_live)

class ProxyCheckDialog(QDialog):
	def __init__(self, accounts, parent=None):
		super().__init__(parent)
		self.setWindowTitle("Ki·ªÉm Tra Proxy & Thay Proxy")
		self.setMinimumSize(600, 400)
		self.accounts = accounts
		self.results = []
		self.die_indexes = []
		self.results = []
		self.live_count = 0
		self.die_count = 0
		self.die_indexes = []


		layout = QVBoxLayout(self)

		self.result_text = QTextEdit(self)
		self.result_text.setReadOnly(True)
		layout.addWidget(self.result_text)

		self.replace_box = QTextEdit(self)
		self.replace_box.setPlaceholderText("Proxy m·ªõi - 1 d√≤ng m·ªói proxy")
		layout.addWidget(self.replace_box)

		buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
		buttons.accepted.connect(self.accept)
		buttons.rejected.connect(self.reject)
		layout.addWidget(buttons)

		self.check_proxies()

	def check_proxies(self):
		self.worker = ProxyCheckWorker(self.accounts)
		self.worker.result_signal.connect(self.update_status)
		self.worker.start()
	def update_status(self, i, status, is_live):
		self.results.append(status)

		item = QTableWidgetItem(status)
		color = QColor("green") if is_live else QColor("red")
		item.setForeground(QBrush(color))
		self.parent().table.setItem(i, 6, item)

		if is_live:
			self.live_count += 1
		else:
			self.die_count += 1
			self.die_indexes.append(i)

		# C·∫≠p nh·∫≠t summary
		summary = f"\nT·ªïng proxy: {len(self.accounts)} | ‚úÖ LIVE: {self.live_count} | ‚ùå DIE: {self.die_count}"
		self.result_text.setText("\n".join(self.results) + summary)


		def apply_proxy_replacements(self):
			new_proxies = [p.strip() for p in self.replace_box.toPlainText().splitlines() if p.strip()]
			for i, idx in enumerate(self.die_indexes):
				if i < len(new_proxies):
					self.accounts[idx][1] = new_proxies[i]

class AccountWorker(QThread):
	update_signal = pyqtSignal(int, str)  # C·∫≠p nh·∫≠t ƒëi·ªÉm cho t√†i kho·∫£n
	log_signal = pyqtSignal(str)  # C·∫≠p nh·∫≠t log

	def __init__(self, accounts, selected_rows):
		super().__init__()
		self.accounts = accounts
		self.selected_rows = selected_rows

	def run(self):
		for row in self.selected_rows:
			try:
				account = self.accounts[row]
				token=account[0]
				proxy=account[1]
				f_id=account[4]
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				headers={
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": f_id,
					"token": token,
					"cache-control": "no-cache",
					"pragma": "no-cache",
					"referer": "https://m.oklavip26.live/",
				}
				responsediem=requests.get("https://m.oklavip26.live/api/wallet/getWallet",headers=headers, proxies=proxies , timeout=500).json()
				
				print(responsediem)
				self.log_signal.emit(f"ƒêang x·ª≠ l√Ω t√†i kho·∫£n: {account[2]}")
				account[5] =f"{responsediem["data"]['integral']}"  
				account[6] = "Ho√†n th√†nh L·∫•y ƒêi·ªÉm"
				self.update_signal.emit(row, account[5])  
				self.log_signal.emit(f"ƒê√£ ho√†n th√†nh t√†i kho·∫£n: {account[2]}")
			except:
				print("L·ªói",account)





class LienKetWorker(QThread):
	result_signal = pyqtSignal(int, str, str)  # row, message, color

	def __init__(self, accounts, row, check_func, table):
		super().__init__()
		self.accounts = accounts
		self.row = row
		self.check_func = check_func
		self.table = table  # ‚úÖ Th√™m tham chi·∫øu ƒë·∫øn b·∫£ng

	def DangNhap(self,account, passwordf, f_id, proxy_string):
		def create_proxy(proxy_string):
			parts = proxy_string.split(":")
			ip = parts[0]
			port = parts[1]
			username = parts[2]
			password = parts[3]
			
			proxies = {
				"http": f"http://{username}:{password}@{ip}:{port}",
				"https": f"http://{username}:{password}@{ip}:{port}"
			}
			return proxies

		# Create the proxies using the provided string
		proxies = create_proxy(proxy_string)

		# URL for captcha request
		url = "https://oklavip26.live/api/accountLogin/captcha"

		# Headers for captcha request
		headers = {
			"accept": "application/json, text/plain, */*",
			"accept-encoding": "gzip, deflate, br, zstd",
			"accept-language": "vi-VN,vi;q=0.9",
			"referer": "https://oklavip26.live/?backRoute=%2Fpersonal",
			"sec-ch-ua": '"Chromium";v="136", "Google Chrome";v="136", "Not.A/Brand";v="99"',
			"sec-ch-ua-mobile": "?0",
			"sec-ch-ua-platform": '"Windows"',
			"sec-fetch-dest": "empty",
			"sec-fetch-mode": "cors",
			"sec-fetch-site": "same-origin",
			"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
		}

		# Attempt login up to 3 times if captcha is invalid
		attempts = 0
		while attempts < 3:
			# Request captcha image
			response = requests.get(url, headers=headers, proxies=proxies)

			# Check status code and print response
			print(response.status_code)
			print(response.json())

			# Extract image and uuid from the response
			img = response.json()
			img_src, uuid = img['data']['image'], img['data']['uuid']

			# Send OCR request to get captcha code
			ocr_response = requests.post("http://103.77.242.210:8000/ocr", headers={"accept": "application/json"}, data={"image": img_src}, verify=False).json()
			code = ocr_response['data']

			# MD5 hash the password
			password_md5 = hashlib.md5(passwordf.encode('utf-8')).hexdigest()

			# Headers for login request
			headers = {
				"authority": "m.oklavip26.live",
				"accept": "application/json, text/plain, */*",
				"accept-language": "vi-VN,vi;q=0.9",
				"content-type": "application/json",
				"locale": "vi_vn",
				"origin": "https://m.oklavip26.live",
				"priority": "u=1, i",
				"referer": "https://m.oklavip26.live/login",
				"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
				"sec-ch-ua-mobile": "?0",
				"sec-ch-ua-platform": "Windows",
				"sec-fetch-dest": "empty",
				"sec-fetch-mode": "cors",
				"sec-fetch-site": "same-origin",
				"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
				"f-id": f_id
			}

			# Prepare data for login
			data = {
				"account": account,
				"password": password_md5,
				"code": code,
				"uuid": uuid,
				"device": "H5"
			}

			# Send login request
			response = requests.post(
				"https://m.oklavip26.live/api/accountLogin/doLogin",
				headers=headers,
				json=data,
				proxies=proxies,
				timeout=20,
			)

			# Print login response
			print(response.json())

			# Check the response for status
			if response.json()['code'] == 200:
				print("Login successful!")
				print(f"Token: {response.json()['data']['token']}")
				return response.json()['data']['token'],"DONE"
			elif response.json()['code'] == 40000:
				print("Invalid captcha code, try again.")
				attempts += 1
			else:
				print(f"Error: {response.json()['message']}")
				break

		print("Failed to login after 3 attempts.")
		return None,response.json()
	def create_proxy(self,proxy_string):
		parts = proxy_string.split(":")
		ip = parts[0]
		port = parts[1]
		username = parts[2]
		password = parts[3]
		
		proxies = {
			"http": f"http://{username}:{password}@{ip}:{port}",
			"https": f"http://{username}:{password}@{ip}:{port}"
		}
		return proxies
	def CheckTokenLive(self,token,Fidd,proxy):
		proxies=self.create_proxy(proxy)
		try:
			headers={
				"authority": "m.oklavip26.live",
				"accept": "application/json, text/plain, */*",
				"accept-language": "vi-VN,vi;q=0.9",
				"content-type": "application/json",
				"locale": "vi_vn",
				"referer": "https://m.oklavip26.live/personal",
				"sec-ch-ua-platform": "Windows",
				"sec-fetch-mode": "cors",
				"sec-fetch-site": "same-origin",
				"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
				"f-id": Fidd,
				"token": token,
			}
			responsediem=requests.get("https://m.oklavip26.live/api/wallet/getWallet",headers=headers, proxies=proxies , timeout=500).json()
			print(responsediem)
			diem=responsediem['data']['integral']
			return False,diem
		except:
			return True,None
	def run(self):
		try:
			account = self.accounts[self.row]
			token = account[0]
			proxy = account[1]
			proxies=self.create_proxy(proxy)
			username = account[2]
			password = account[3]
			f_id = account[4]
			self.result_signal.emit(self.row, "Loading......", "green")
			self.result_signal.emit(self.row, "[‚ùå‚ùå‚ùå] Ch·ªù M·∫°ng (PROXY)", "green")
			headers = {
				"authority": "m.oklavip26.live",
				"accept": "application/json, text/plain, */*",
				"accept-language": "vi-VN,vi;q=0.9",
				"content-type": "application/json",
				"locale": "vi_vn",
				"origin": "https://m.oklavip26.live",
				"priority": "u=1, i",
				"referer": "https://m.oklavip26.live/login",
				"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
				"sec-ch-ua-mobile": "?0",
				"sec-ch-ua-platform": "Windows",
				"sec-fetch-dest": "empty",
				"sec-fetch-mode": "cors",
				"sec-fetch-site": "same-origin",
				"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
				"f-id": f_id,
				"token": token
			}
			TrangThaiDangNhap,dime=self.CheckTokenLive(token,f_id,proxy)

			if TrangThaiDangNhap:
				self.result_signal.emit(self.row, "[‚ùå‚ùå‚ùå] Ch·ªù ƒêƒÉng Nh·∫≠p Th·ª≠ L·∫°i", "red")
				token,log = self.DangNhap(username, password, f_id, proxy)
				if token is None:
					self.result_signal.emit(self.row, f"[‚ùå‚ùå‚ùå] {log}", "red")
					print(log)
				if log == "DONE":
					self.table.setItem(self.row, 0, QTableWidgetItem(token))  # ‚úÖ Ghi token m·ªõi v√†o c·ªôt 0
					self.result_signal.emit(self.row, f"‚úÖ ƒêƒÉng Nh·∫≠p Th√†nh C√¥ng", "green")
				else:
					self.result_signal.emit(self.row, f"{log}", "green")
				return


			response = requests.get("https://m.oklavip26.live/api/website/listForWallet", headers=headers, proxies=proxies, timeout=500).json()
			is_linked = any(site.get("isBind", False) for site in response.get("data", []))

			if is_linked:
				self.result_signal.emit(self.row, "‚úÖ Token C√≤n Ho·∫°t ƒê·ªông T·ªët!!!!", "green")

			else:
				self.result_signal.emit(self.row, "‚ùå Ch∆∞a Li√™n K·∫øt ti·∫øn h√†nh t·∫°o OK9 Li√™n k·∫øt", "red")
				fake = Faker('vi_VN')
				lock = threading.Lock()

				proxy="103.74.106.155:38675:xunj3o6b:xUnJ3o6B"
				host, port, userss, pwd = proxy.split(":")
				proxy_url = f"http://{userss}:{pwd}@{host}:{port}"
				proxies = {"http": proxy_url, "https": proxy_url}

				# Global session
				session = requests.Session()
				session.headers = {
					"Content-Type": "application/json",
					"accept-language": "en-US,en;q=0.9,vi;q=0.8",
					"origin": "https://www.010070.com",
					"priority": "u=1, i",
					"referer": "https://www.010070.com/vit/home/index/in-play",
					"sec-ch-ua": '"Google Chrome";v="135", "Not-A.Brand";v="8", "Chromium";v="135"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": '"Windows"',
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"x-kzapi-domain": "www.010070.com",
					"x-kzapi-language": "vit",
					"x-kzapi-platform": "web",
					"x-kzapi-timezone": "+07:00",
					"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36"
				}

				# --- Functions ---

				def encrypt_data(data: str, public_key: str):
					rsa_key = RSA.import_key(public_key)
					cipher = PKCS1_v1_5.new(rsa_key)
					encrypted_bytes = cipher.encrypt(data.encode())
					return base64.b64encode(encrypted_bytes).decode()

				def get_encryption_key():
					url = "https://www.010070.com/api/encryption-key"
					payload = "{}"
					response = session.post(url, data=payload)
					if response.status_code == 200:
						return response.json()['data']['publicKey']
					else:
						return None

				def random_string(length=10):
					return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

				def random_number(length=8):
					return '9' + ''.join(random.choices(string.digits, k=length))

				def random_STK():
					return ''.join(random.choices(string.digits, k=random.randint(9,12)))

				def get_random_name():
					try:
						url = 'https://story-shack-cdn-v2.glitch.me/generators/vietnamese-name-generator/'
						response = requests.get(url)
						random_sex = random.choice(['male', 'female'])
						return response.json()['data'][random_sex]
					except:
						return 'Nguyen Van Thinh'

				def remove_accents(text: str):
					if text:
						return unidecode(text)
					else:
						return ''

				def add_card(bankCode: str, account: str, stk: str):
					try:
						url = "https://www.010070.com/api/add-bankcard"
						payload = {
							"bankCode": bankCode,
							"account": account,
							"card": stk,
							"bankNode": "HA NOI",
							"note": "",
							"needSms": False,
							"smsCode": "",
							"smsPhoneNo": "",
							"smsPhoneNoCountry": "vn",
							"bankpassbook": "",
							"addrA": "",
							"addrB": "",
							"ifsccode": ""
						}
						response = session.post(url, json=payload, proxies=proxies)
						if response.status_code == 200 and response.json()['status'] == 0:
							print(f"‚úÖ Th√™m bank th√†nh c√¥ng: {stk}")
							return True
						else:
							print(f"‚ùå Th√™m bank th·∫•t b·∫°i: {stk} | {response.json().get('message')}")
							return False
					except Exception:
						traceback.print_exc()
						return False

				def do_register():
					try:
						url = "https://www.010070.com/api/register-account-v2"
						user = random_string(9)
						fullname = get_random_name()
						fullname = remove_accents(fullname).upper()
						password = random_string(12) + '0a'
						phone = random_number()
						print(f"ƒêƒÉng k√Ω v·ªõi: {user}, {password}, {fullname}")

						payload = {
							"verifycode": "",
							"email": "",
							"joinpwd": encrypt_data(password, get_encryption_key()),
							"joiname": user,
							"birthmonth": random.randint(1, 12),
							"birthyear": random.randint(1980, 2005),
							"jsessionid": random_string(32).upper(),
							"birthday": None,
							"fullname": fullname,
							"nickname": "",
							"agc": "12531",
							"wdpassword": "",
							"weixin": "",
							"line": "",
							"whatsapp": "",
							"telegram": "",
							"facebook": "",
							"tiktok": "",
							"x": "",
							"zalo": "",
							"google": "",
							"skype": "",
							"qq": "",
							"regpath": "/vit/home/index/in-play",
							"emailcode": "",
							"smscode": "",
							"autologin": "1",
							"redirectedFromDomain": "www.010070.com",
							"gpn": "",
							"rfc": "",
							"adminreferal": None,
							"utm_code": None,
							"visitor_id": None,
							"captchaValidate": "",
							"wtdCardBankCode": "",
							"wtdCardBankName": "T√™n ng√¢n h√†ng",
							"wtdCardNumber": "",
							"uphonecountry": "vn",
							"uphone": phone
						}

						response = session.post(url, json=payload, proxies=proxies)
						if response.status_code == 200 and response.json()['status'] == 0:
							user_token = response.json()['data']['_userToken']
							session.headers['x-kzapi-User'] = user_token

							# Th√™m bank sau khi ƒëƒÉng k√Ω
							for _ in range(3):
								stk = random_STK()
								if add_card("VNVCB", fullname, stk):
									break

							return user, password, fullname, phone
						else:
							print(f"‚ùå ƒêƒÉng k√Ω th·∫•t b·∫°i: {response.text}")
							return False
					except Exception:
						traceback.print_exc()
						return False

				def create_account_and_save():
					status = do_register()
					if status:
						user, password, fullname, phone = status
						print(f"‚úÖ T·∫°o th√†nh c√¥ng: {user}")
						return user,phone
					else:
						print("‚ùå ƒêƒÉng k√Ω th·∫•t b·∫°i.")

				gameAccount,fullPhone=create_account_and_save()
				gamePhone = fullPhone[-4:]

			  
				# T·∫°o data g·ª≠i
				data = {
					"gameAccount": gameAccount,
					"gamePhone": gamePhone,
					"websiteId": "1798608608416931842",
					"memberCode": "OK9"
				}

				try:
					response = requests.post(
						"https://m.oklavip26.live/api/wallet/bindGameAccount",
						headers=headers,
						proxies=proxies,
						json=data,
						timeout=20
					)
					message = response.json().get('message', '')
					print(message)
					self.result_signal.emit(self.row, f"{message}", "red")
				  
				except Exception as e:
					print(f"L·ªói g·ª≠i request: {e}")
					self.result_signal.emit(self.row, f"L·ªói g·ª≠i request: {e}", "red")
				response = requests.get("https://m.oklavip26.live/api/website/listForWallet", headers=headers, proxies=proxies, timeout=500).json()
				is_linked = any(site.get("isBind", False) for site in response.get("data", []))

				if is_linked:
					self.result_signal.emit(self.row, "‚úÖ ƒê√£ C√≥ Li√™n K·∫øt", "green")
				else:
					self.result_signal.emit(self.row, "‚ùå Ch∆∞a Li√™n K·∫øt", "red")


		except Exception as e:
			self.result_signal.emit(self.row, f"‚ùå L·ªói: {str(e)}", "red")



class MainWindow(QWidget):
	def __init__(self):
		super().__init__()
		self.accounts = []  # D·ªØ li·ªáu t√†i kho·∫£n
		self.threads = []  # Danh s√°ch lu·ªìng ƒëang ch·∫°y
		
		# Load tool key and set max threads
		if not self.load_tool_key():
			QMessageBox.critical(self, "L·ªói", "Kh√¥ng th·ªÉ ƒë·ªçc file tool_key.json")
			self.close()
			return
		
		# Start expiration check and countdown timer
		self.start_expiration_check()
		self.start_countdown_timer()
		
		self.init_ui()
		self.load_accounts_from_file()
		self.start_auto_save()
	def open_proxy_checker(self):
		dlg = ProxyCheckDialog(self.accounts, self)
		if dlg.exec():
			dlg.apply_proxy_replacements()
			self.reload_table()
			self.save_accounts_to_file()

	def init_ui(self):
		self.setWindowTitle("Qu·∫£n l√Ω t√†i kho·∫£n")
		self.setGeometry(100, 100, 1200, 700)

		# ========== Thi·∫øt l·∫≠p m√†u n·ªÅn ch√≠nh ==========
		self.setStyleSheet("background-color: #252526; color: white;")

		# ========== Layout t·ªïng ==========
		main_layout = QHBoxLayout(self)

		# ========== Menu b√™n tr√°i ==========
		self.side_menu = QVBoxLayout()
		self.side_menu.setAlignment(Qt.AlignmentFlag.AlignTop)

		# Add countdown timer label in top right
		self.countdown_label = QLabel()
		self.countdown_label.setStyleSheet("""
			QLabel {
				color: #00ff00;
				font-size: 14px;
				font-weight: bold;
				padding: 5px;
				background-color: #2b2b2b;
				border-radius: 5px;
			}
		""")
		self.countdown_label.setAlignment(Qt.AlignmentFlag.AlignRight)
		
		# Add countdown to side menu
		self.side_menu.addWidget(self.countdown_label)

		self.home_button = QPushButton("üè† Home")
		self.proxy_button = QPushButton("üåê Proxy")
		for btn in [self.home_button, self.proxy_button]:
			btn.setFixedHeight(40)
			btn.setStyleSheet("""
				QPushButton {
					font-size: 14px;
					padding: 8px;
					background-color: #4e4e4e;
					border: none;
					color: white;
				}
				QPushButton:hover {
					background-color: #5e5e5e;
				}
			""")

		self.side_menu.addWidget(self.home_button)
		self.side_menu.addWidget(self.proxy_button)

		# Th√™m n√∫t "Th√™m t√†i kho·∫£n" v√†o menu b√™n tr√°i
		self.add_account_button = QPushButton("‚ûï Th√™m T√†i Kho·∫£n")
		self.add_account_button.setFixedHeight(40)
		self.add_account_button.setStyleSheet("""
			QPushButton {
				font-size: 14px;
				padding: 8px;
				background-color: #4e4e4e;
				border: none;
				color: white;
			}
			QPushButton:hover {
				background-color: #5e5e5e;
			}
		""")
		self.side_menu.addWidget(self.add_account_button)
		
		# K·∫øt n·ªëi s·ª± ki·ªán click
		self.add_account_button.clicked.connect(self.show_add_account_dialog)

		side_menu_widget = QWidget()
		side_menu_widget.setLayout(self.side_menu)
		side_menu_widget.setFixedWidth(150)
		
		main_layout.addWidget(side_menu_widget)

		# ========== Stack n·ªôi dung ==========
		self.stack = QStackedWidget()

		# Trang HOME
		self.home_page = QWidget()
		self.init_home_ui(self.home_page)
		self.stack.addWidget(self.home_page)

		# Trang PROXY
		self.proxy_page = QWidget()
		self.init_proxy_ui(self.proxy_page)
		self.stack.addWidget(self.proxy_page)

		main_layout.addWidget(self.stack)

		# ====== S·ª± ki·ªán ======
		self.home_button.clicked.connect(lambda: self.stack.setCurrentWidget(self.home_page))
		self.proxy_button.clicked.connect(lambda: self.stack.setCurrentWidget(self.proxy_page))

	def check_all_proxies(self):
		row_count = self.table.rowCount()
		proxies_seen = set()
		proxy_list = []

		for row in range(row_count):
			proxy_item = self.table.item(row, 1)
			if proxy_item:
				proxy_text = proxy_item.text().strip()
				if proxy_text and proxy_text not in proxies_seen:
					proxies_seen.add(proxy_text)
					proxy_list.append(proxy_text)

		self.proxy_table.setRowCount(len(proxy_list))
		self.proxy_table.setColumnCount(2)
		self.proxy_table.setHorizontalHeaderLabels(["Proxy", "K·∫øt qu·∫£"])
		self.proxy_table.horizontalHeader().setStretchLastSection(True)

		def check_proxy(proxy):
			try:
				proxies = create_proxy(proxy)
				resp = requests.get("https://geo.myip.link/", proxies=proxies, timeout=10)
				data = resp.json()
				country = data.get("country", "Unknown")
				city = data.get("city", "")
				ip = data.get("ip", "")
				return proxy, f"‚úÖ {ip} | {city}, {country}"
			except Exception as e:
				return proxy, "‚ùå Kh√¥ng k·∫øt n·ªëi"

		# Update the ThreadPoolExecutor to use max_threads
		with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
			future_to_proxy = {executor.submit(check_proxy, proxy): proxy for proxy in proxy_list}
			for i, future in enumerate(as_completed(future_to_proxy)):
				proxy, result = future.result()
				self.proxy_table.setItem(i, 0, QTableWidgetItem(proxy))
				self.proxy_table.setItem(i, 1, QTableWidgetItem(result))

		self.proxy_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
	def init_proxy_ui(self, parent):
		layout = QVBoxLayout(parent)
		label = QLabel("üõ∞Ô∏è Ki·ªÉm tra proxy:")
		label.setStyleSheet("font-size: 16px; color: white;")
		layout.addWidget(label)

		self.proxy_table = QTableWidget()
		self.proxy_table.setColumnCount(2)
		self.proxy_table.setHorizontalHeaderLabels(["Proxy", "Tr·∫°ng th√°i"])
		layout.addWidget(self.proxy_table)

		check_button = QPushButton("üîç Ki·ªÉm tra t·∫•t c·∫£ proxy")
		check_button.clicked.connect(lambda: threading.Thread(target=self.check_all_proxies).start())

		layout.addWidget(check_button)
	def save_selected_rows_to_group_file(self):
		selected_ranges = self.table.selectedRanges()
		if not selected_ranges:
			self.status_label.setText("‚ö†Ô∏è Ch∆∞a ch·ªçn d√≤ng n√†o ƒë·ªÉ t·∫°o nh√≥m.")
			return

		import csv
		from pathlib import Path

		file_path = Path("groups.csv")
		headers = [self.table.horizontalHeaderItem(i).text() for i in range(self.table.columnCount())]
		full_headers = ["GroupID"] + headers

		rows_to_save = []

		for range_ in selected_ranges:
			for row in range(range_.topRow(), range_.bottomRow() + 1):
				row_data = [self.table.item(row, col).text() if self.table.item(row, col) else "" for col in range(self.table.columnCount())]
				rows_to_save.append([self.group_id] + row_data)

		file_exists = file_path.exists()
		with open(file_path, mode="a", newline='', encoding="utf-8") as f:
			writer = csv.writer(f)
			if not file_exists:
				writer.writerow(full_headers)
			writer.writerows(rows_to_save)

		self.status_label.setText(f"‚úÖ ƒê√£ l∆∞u nh√≥m {self.group_id} ({len(rows_to_save)} d√≤ng).")
		self.group_id += 1
		self.group_filter_combo.addItem(str(self.group_id - 1))
	def filter_table_by_group(self, selected_group):
		for row in range(self.table.rowCount()):
			item = self.table.item(row, 0)  # C·ªôt GroupID kh√¥ng c√≥ trong table hi·ªán t·∫°i, ta d√πng Note ho·∫∑c Status thay th·∫ø
			match = False
			if selected_group == "T·∫•t c·∫£":
				match = True
			else:
				# Gi·∫£ s·ª≠ b·∫°n g√°n GroupID t·∫°m v√†o c·ªôt Note (index 7)
				cell_value = self.table.item(row, 7).text() if self.table.item(row, 7) else ""
				match = (cell_value == selected_group)
			self.table.setRowHidden(row, not match)

	def init_home_ui(self, parent):
		layout = QVBoxLayout(parent)

		# ============ MENU H√ÄNG TR√äN ============
		menu_bar_layout = QHBoxLayout()

		self.theme_button = QPushButton("üåô Ch·∫ø ƒë·ªô T·ªëi")
		self.sort_asc_button = QPushButton("üîº Th·∫•p ‚Üí Cao")
		self.sort_desc_button = QPushButton("üîΩ Cao ‚Üí Th·∫•p")
		self.reset_button = QPushButton("üîÅ Reset")
		self.backup_button = QPushButton("üõ°Ô∏è Backup")
		self.create_group_button = QPushButton("‚ûï T·∫°o Nh√≥m")
		self.status_filter_combo = QComboBox()
		self.status_filter_combo.addItems(["T·∫•t c·∫£", "Th√†nh c√¥ng", "Th·∫•t b·∫°i"])

		self.group_filter_combo = QComboBox()
		self.group_filter_combo.addItem("T·∫•t c·∫£")
		self.text_input = QLineEdit()
		self.text_input.setPlaceholderText("Nh·∫≠p n·ªôi dung t·∫°i ƒë√¢y...")
		self.text_input.setStyleSheet("font-size: 14px; padding: 6px;")
		layout.addWidget(self.text_input)

		for widget in [self.create_group_button, self.theme_button, self.sort_asc_button,
					   self.sort_desc_button, self.reset_button, self.backup_button,
					   self.status_filter_combo, self.group_filter_combo]:
			widget.setStyleSheet("QPushButton, QComboBox {font-size: 14px; padding: 6px;}")
			menu_bar_layout.addWidget(widget)

		layout.addLayout(menu_bar_layout)

		# G√°n s·ª± ki·ªán
		self.create_group_button.clicked.connect(self.save_selected_rows_to_group_file)
		self.status_filter_combo.currentTextChanged.connect(self.filter_by_status)
		self.group_filter_combo.currentTextChanged.connect(self.filter_table_by_group)
		self.theme_button.clicked.connect(self.toggle_theme)
		self.sort_asc_button.clicked.connect(self.sort_by_points_asc)
		self.sort_desc_button.clicked.connect(self.sort_by_points_desc)
		self.reset_button.clicked.connect(self.reset_table)
		self.backup_button.clicked.connect(self.backup_accounts)

		# Bi·∫øn ƒë·∫øm nh√≥m
		self.group_id = 1

		# ============ B·∫¢NG T√ÄI KHO·∫¢N ============
		self.table = QTableWidget()
		self.table.setColumnCount(9)
		self.table.setHorizontalHeaderLabels(["Token", "Proxy", "User", "Pass", "F_ID", "ƒêi·ªÉm", "Status", "Note", "ƒêi·ªÉm danh"])
		self.table.horizontalHeader().setStyleSheet("color: white; background-color: #3a3b45;")
		self.table.setAlternatingRowColors(True)
		self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
		self.table.setSortingEnabled(True)  # ‚úÖ B·∫≠t sorting khi click ti√™u ƒë·ªÅ c·ªôt
		self.table.setStyleSheet("""
			QHeaderView::section {
				color: white;
				background-color: #3a3b45;
			}
			QTableWidget {
				color: white;
				background-color: #2e2f38;
				alternate-background-color: #3a3b45;
			}
		""")
		self.table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeMode.Stretch)
		layout.addWidget(self.table)

		# ============ SPINBOX ============
		self.spinbox = QSpinBox()
		self.spinbox.setRange(1, 10)
		self.spinbox.setValue(1)
		self.spinbox.setStyleSheet("QSpinBox {font-size: 14px;}")
		layout.addWidget(self.spinbox)

		# ============ TR·∫†NG TH√ÅI ============
		status_layout = QHBoxLayout()

		self.log_label = QLabel()
		self.log_label.setStyleSheet("QLabel {font-size: 24px; color: green;}")
		status_layout.addWidget(self.log_label)

		self.status_label = QLabel()
		self.status_label.setStyleSheet("QLabel {font-size: 12px; color: blue;}")
		status_layout.addWidget(self.status_label)

		layout.addLayout(status_layout)

		# ============ T·ªîNG ƒêI·ªÇM ============
		self.total_points_label = QLabel("T·ªïng ƒëi·ªÉm: 0 | T·ªïng t√†i kho·∫£n: 0 | ƒêi·ªÉm cao nh·∫•t: 0")
		self.total_points_label.setStyleSheet("QLabel {font-size: 14px; color: red;}")
		self.total_points_label.setAlignment(Qt.AlignmentFlag.AlignRight)
		layout.addWidget(self.total_points_label)

		# ============ N√öT PROXY ============
		self.replace_proxy_button = QPushButton("‚ôªÔ∏è Thay Proxy [‚ùå‚ùå‚ùå] Ch·ªù ƒêƒÉng Nh·∫≠p Th·ª≠ L·∫°i")
		self.replace_proxy_button.clicked.connect(self.replace_proxies_for_failed_accounts)
		self.replace_proxy_button.setStyleSheet("QPushButton {font-size: 14px; padding: 6px;}")
		layout.addWidget(self.replace_proxy_button)


	def toggle_menu(self):
		# Khi b·∫•m n√∫t MENU
		if self.menu_open:
			# ·∫®n c√°c n√∫t ch·ª©c nƒÉng
			self.theme_button.hide()
			self.sort_asc_button.hide()
			self.sort_desc_button.hide()
			self.reset_button.hide()
			self.backup_button.hide()
			self.status_filter_combo.hide()
			self.menu_button.setText("‚ò∞ Menu")
		else:
			# Hi·ªán c√°c n√∫t ch·ª©c nƒÉng
			self.theme_button.show()
			self.sort_asc_button.show()
			self.sort_desc_button.show()
			self.reset_button.show()
			self.backup_button.show()
			self.status_filter_combo.show()
			self.menu_button.setText("‚úñ ƒê√≥ng Menu")
		self.menu_open = not self.menu_open
		self.replace_proxy_button.setVisible(self.menu_open)

	def replace_proxies_for_failed_accounts(self):

		# L·ªçc c√°c d√≤ng c·∫ßn thay proxy
		failed_rows = []
		for row in range(self.table.rowCount()):
			status_item = self.table.item(row, 6)
			if status_item:
				txt = status_item.text()
				if ("‚ùå L·ªói: HTTPSConnectionPool(host='m.oklavip26.live'" in txt
					or "[‚ùå‚ùå‚ùå] Ch·ªù ƒêƒÉng Nh·∫≠p Th·ª≠ L·∫°i" in txt
					or "[‚ùå‚ùå‚ùå] Ch·ªù M·∫°ng (PROXY)" in txt
					or "‚ùå Proxy kh√¥ng ho·∫°t ƒë·ªông." in txt):
					failed_rows.append(row)

		if not failed_rows:
			self.log_label.setText("Kh√¥ng c√≥ t√†i kho·∫£n n√†o c·∫ßn thay proxy.")
			return

		# H·ªèi ng∆∞·ªùi d√πng nh·∫≠p proxy th·ªß c√¥ng
		text, ok = QInputDialog.getMultiLineText(
			self, "Nh·∫≠p proxy m·ªõi",
			f"Nh·∫≠p {len(failed_rows)} proxy m·ªõi (1 d√≤ng 1 proxy):"
		)

		if ok:
			proxies = [line.strip() for line in text.strip().splitlines() if line.strip()]
			need_more = len(failed_rows) - len(proxies)

			# N·∫øu thi·∫øu th√¨ t·ª± ƒë·ªông mua th√™m proxy
			if need_more > 0:
				try:
					url = f"https://clonebysun.com/api/BResource.php?username=t29032006&password=t29032006&id=86&amount={need_more}"
					response = requests.get(url)
					data = response.json()

					if data["status"] != "success":
						QMessageBox.warning(self, "L·ªói", "Kh√¥ng th·ªÉ mua proxy: " + data.get("msg", ""))
						return

					bought_proxies = [entry["account"] for entry in data["data"]["lists"]]
					if len(bought_proxies) < need_more:
						QMessageBox.warning(self, "Thi·∫øu proxy", f"API ch·ªâ tr·∫£ v·ªÅ {len(bought_proxies)} proxy.")
						return

					proxies.extend(bought_proxies)
					QMessageBox.warning(self, "Th√†nh C√¥ng", f"Thay Th√†nh C√¥ng")

				except Exception as e:
					QMessageBox.critical(self, "L·ªói", f"ƒê√£ x·∫£y ra l·ªói khi mua proxy: {str(e)}")
					return

			# √Åp d·ª•ng proxy cho t·ª´ng d√≤ng l·ªói
			for i, row in enumerate(failed_rows):
				new_proxy = proxies[i]
				self.table.setItem(row, 1, QTableWidgetItem(new_proxy))
				self.accounts[row][1] = new_proxy

			self.log_label.setText(f"‚úÖ ƒê√£ thay {len(failed_rows)} proxy.")
			self.save_accounts_to_file()


	def backup_accounts(self):
		try:
			now = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
			backup_filename = f"ACC_backup_{now}.txt"
			with open("ACC.txt", "r", encoding="utf-8") as f_original, open(backup_filename, "w", encoding="utf-8") as f_backup:
				f_backup.write(f_original.read())
			self.log_label.setText(f"ƒê√£ backup th√†nh: {backup_filename}")
		except Exception as e:
			self.log_label.setText(f"L·ªói backup: {str(e)}")

	def filter_by_status(self, selected_status):
		if selected_status == "ALL":
			self.reload_table()
			return

		self.table.setRowCount(0)
		for acc in self.accounts:
			status = acc[7] if len(acc) > 7 else ""
			if selected_status == status:
				row = self.table.rowCount()
				self.table.insertRow(row)
				for col, value in enumerate(acc):
					item = QTableWidgetItem(value)
					item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
					self.table.setItem(row, col, item)

	def update_status_filter(self):
		status_set = set()
		for row in range(self.table.rowCount()):
			item = self.table.item(row, 7)  # C·ªôt status
			if item:
				status_set.add(item.text().strip())

		current = self.status_filter_combo.currentText()
		self.status_filter_combo.blockSignals(True)
		self.status_filter_combo.clear()
		self.status_filter_combo.addItem("ALL")
		self.status_filter_combo.addItems(sorted(status_set))
		self.status_filter_combo.setCurrentText(current)
		self.status_filter_combo.blockSignals(False)


	def sort_by_points_asc(self):
		self.accounts.sort(key=lambda acc: int(acc[5]) if acc[5].isdigit() else 0)
		self.reload_table()

	def sort_by_points_desc(self):
		self.accounts.sort(key=lambda acc: int(acc[5]) if acc[5].isdigit() else 0, reverse=True)
		self.reload_table()

	def reset_table(self):
		self.load_accounts_from_file()

	def reload_table(self):
		self.table.setRowCount(0)
		for data in self.accounts:
			row = self.table.rowCount()
			self.table.insertRow(row)
			for col, value in enumerate(data):
				item = QTableWidgetItem(value)
				item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
				self.table.setItem(row, col, item)
		self.update_status_filter()

	def toggle_theme(self):
		if self.theme == "light":
			self.theme = "dark"
			self.setStyleSheet("""
				QWidget {
					background-color: #121212;
					color: white;
				}
				QTableWidget, QSpinBox, QLabel {
					background-color: #1e1e1e;
					color: white;
					border: 1px solid #333;
				}
				QPushButton {
					background-color: #333;
					color: white;
				}
				QPushButton:hover {
					background-color: #444;
				}
			""")
			self.theme_button.setText("‚òÄÔ∏è Ch·∫ø ƒë·ªô S√°ng")
		else:
			self.theme = "light"
			self.setStyleSheet("")
			self.theme_button.setText("üåô Ch·∫ø ƒë·ªô T·ªëi")


	def load_accounts_from_file(self):
		try:
			# X√≥a b·∫£ng v√† danh s√°ch c≈©
			self.table.setRowCount(0)
			self.accounts.clear()
			self.update_status_filter()
			with open("ACC.txt", "r", encoding="utf-8") as f:
				lines = f.readlines()
				for line in lines:
					data = line.strip().split("|")
					while len(data) < 8:
						data.append("")
					self.accounts.append(data)
					row = self.table.rowCount()
					self.table.insertRow(row)
					for col, value in enumerate(data):
						item = QTableWidgetItem(value)
						item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
						self.table.setItem(row, col, item)
					self.table.setItem(row, 5, QTableWidgetItem(data[5] if data[5] else "0"))
					self.table.setItem(row, 6, QTableWidgetItem(data[6] if data[6] else "Ch∆∞a x·ª≠ l√Ω"))
					self.table.setItem(row, 7, QTableWidgetItem(data[7]))  # Note
					self.update_status_filter()

		except Exception as e:
			self.log_label.setText(f"L·ªói khi ƒë·ªçc file: {str(e)}")

	def save_accounts_to_file(self):

		try:
			self.update_total_points()

			with open("ACC.txt", "w", encoding="utf-8") as f:
				for row in range(self.table.rowCount()):
					values = []
					for col in range(self.table.columnCount()):
						item = self.table.item(row, col)
						values.append(item.text() if item else "")
					f.write("|".join(values) + "\n")
			timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
			self.log_label.setText(f"ƒê√£ l∆∞u l·∫°i th√¥ng tin v√†o file l√∫c {timestamp}.")
		except Exception as e:
			self.log_label.setText(f"L·ªói khi l∆∞u file: {str(e)}")


	def update_total_points(self):
		total = 0
		max_point = 0
		DiemCOthedung = 0

		count = self.table.rowCount()
		for row in range(count):
			item = self.table.item(row, 5)
			note = self.table.item(row, 7)
			chuoi=note.text()
			if item:
				try:
					point = int(item.text())
					total += point
				   
					if any(keyword in chuoi for keyword in ["MB66", "78win", "QQ88"]):
						DiemCOthedung+=point
						if point > max_point:
							max_point = point

				except ValueError:
					continue
		self.total_points_label.setText(
			f"T·ªïng ƒëi·ªÉm: {total} | T·ªïng t√†i kho·∫£n: {count} | ƒêi·ªÉm cao nh·∫•t: {max_point} | ƒêi·ªÉm C√≥ Th·ªÉ D√πng : {DiemCOthedung}"
		)


	def start_auto_save(self):
		self.timer = QTimer(self)
		self.timer.timeout.connect(self.save_accounts_to_file)
		self.timer.start(3000)  # L∆∞u l·∫°i sau m·ªói 5 gi√¢y
	def LayLaiTokenChoTokenChetttt(self):
		from PyQt6.QtWidgets import QTableWidgetItem
		for row in range(self.table.rowCount()):
			status_item = self.table.item(row, 6)
			if status_item and "[üí©üí©üí©]> Token Ch·∫øt M·∫∏ R·ªìi em!" in status_item.text():
				account = self.accounts[row]
				proxy = account[1]
				username = account[2]
				password = account[3]
				f_id = account[4]
				self.table.setItem(row, 6, QTableWidgetItem("ƒêang L·∫•y L·∫°i Token"))

				worker = LienKetWorker(self.accounts, row, self.CheckLoginssssss, self.table)
				token, log = worker.DangNhap(username, password, proxy, f_id)
				if token:
					self.accounts[row][0] = token
					self.table.setItem(row, 0, QTableWidgetItem(token))
					self.table.setItem(row, 6, QTableWidgetItem("‚úÖ ƒê√£ L·∫•y L·∫°i Token"))
				else:
					self.table.setItem(row, 6, QTableWidgetItem("‚ùå ƒêƒÉng Nh·∫≠p L·∫°i Th·∫•t B·∫°i"))
	def SetMaPinChoTaiKhoan(self, row):

		def set_pin_for_account(row):
			try:
				account = self.accounts[row]
				token = account[0]
				proxy = account[1]
				f_id = account[4]

				# D·ªØ li·ªáu g·ª≠i: m√£ PIN l√† MD5 c·ªßa "1234"
				payload = {
					"newWithdrawPassword": "4297f44b13955235245b2497399d7a93",
					"confirmWithdrawPassword": "4297f44b13955235245b2497399d7a93"
				}

				headers = {
					"accept": "application/json, text/plain, */*",
					"content-type": "application/json",
					"locale": "vi_vn",
					"referer": "https://m.okvip19.live/setWithDrawalpass",
					"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": f_id,
					"token": token
				}

				# X·ª≠ l√Ω th√¥ng tin proxy
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}

				# URL API
				url = "https://m.okvip19.live/api/account/setWithdrawPassword"
				response = requests.post(url, headers=headers, json=payload, proxies=proxies, timeout=15)

				# Ki·ªÉm tra k·∫øt qu·∫£ ph·∫£n h·ªìi
				if response.status_code == 200 and response.json().get("message") == "Thao t√°c th√†nh c√¥ng":
					self.table.setItem(row, 6, QTableWidgetItem("‚úÖ ƒê√£ Set M√£ PIN"))
				else:
					error_message = response.json().get("message", "Kh√¥ng x√°c ƒë·ªãnh")
					self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå L·ªói Set PIN {error_message}"))
					print(response.json())

			except Exception as e:
				self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå L·ªói: {str(e)}"))

		with ThreadPoolExecutor(max_workers=99) as executor:
			futures = [executor.submit(set_pin_for_account, row) for row in range(len(self.accounts))]
			for future in as_completed(futures):
				future.result()  # Ch·ªù c√°c lu·ªìng ho√†n th√†nh
	class ThuanLienKet(QThread):
		result = pyqtSignal(int, str)  # row, message

		def __init__(self, selected_rows, accounts, game_info, game_account, game_phone):
			super().__init__()
			self.selected_rows = selected_rows
			self.accounts = accounts
			self.game_info = game_info
			self.game_account = game_account
			self.game_phone = game_phone

		def run(self):
			row=self.selected_rows[0]
			account = self.accounts[self.selected_rows[0]]
			token = account[0]
			proxy = account[1]
			tkkk = account[2]
			password = account[3]
			f_id = account[4]
			print(account)
			headers = {
				"accept": "application/json, text/plain, */*",
				"content-type": "application/json",
				"f-id": f_id,
				"locale": "vi_vn",
				"referer": "https://m.oklavip26.live/wallet?type=0",
				"token": token,
				"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
			}

			data = {
				"gameAccount": self.game_account,
				"gamePhone": self.game_phone,
				"websiteId": self.game_info["id"],
				"memberCode": self.game_info["memberCode"]
			}

			try:
				proxies = create_proxy(proxy)
				response = requests.post(
					"https://m.oklavip26.live/api/wallet/bindGameAccount",
					headers=headers,
					json=data,
					proxies=proxies,
					timeout=10
				)
				self.result.emit(row, f"‚úÖ {response.status_code} - {response.text}")
			except Exception as e:
				self.result.emit(row, f"‚ùå L·ªói: {str(e)}")
	def Thuanrutdiemday(self):
		if hasattr(self, "thuan_lienket_thread") and self.thuan_lienket_thread is not None and self.thuan_lienket_thread.isRunning():
			print("ƒêang ch·∫°y, vui l√≤ng ƒë·ª£i xong!")
			return
		game_list = [
			{"memberCode": "MOCBAI", "websiteName": "MB66", "id": "1739230912039436290"},
			{"memberCode": "OK9", "websiteName": "OK9", "id": "1798608608416931842"},
			{"memberCode": "78win", "websiteName": "78win", "id": "1814571722874535937"},
			{"memberCode": "QQ88", "websiteName": "QQ88", "id": "1863085503318499329"},
			{"memberCode": "F168", "websiteName": "F168", "id": "1863085976314355713"},
		]
		dialog = GameInputDialog(game_list,"R√∫t ƒêi·ªÉm","S·ªë ƒêi·ªÉm Mu·ªën R√∫t","M√£ PIN")
		if dialog.exec():
			game_info = dialog.selected_game
			game_account = dialog.game_account
			game_phone = dialog.game_phone
		else:
			return
		selected_rows = [index.row() for index in self.table.selectedIndexes()]
		# N·∫øu ƒë√£ c√≥ thread c≈©, disconnect signal tr∆∞·ªõc khi t·∫°o m·ªõi
		if hasattr(self, "thuan_lienket_thread") and self.thuan_lienket_thread is not None:
			try:
				self.thuan_lienket_thread.result.disconnect(self.handle_lienket_tuychon_result)
			except Exception:
				pass
		self.thuan_lienket_thread = self.Thuanrutdiem(selected_rows, self.accounts, game_info, game_account, game_phone)
		self.thuan_lienket_thread.result.connect(self.handle_lienket_tuychon_result)
		self.thuan_lienket_thread.start()

	class Thuanrutdiem(QThread):
		result = pyqtSignal(int, str)  # row, message

		def __init__(self, selected_rows, accounts, game_info, game_account, game_phone):
			super().__init__()
			self.selected_rows = selected_rows
			self.accounts = accounts
			self.game_info = game_info
			self.game_account = game_account
			self.game_phone = game_phone

		def run(self):
			row=self.selected_rows[0]
			account = self.accounts[self.selected_rows[0]]
			token = account[0]
			proxy = account[1]
			tkkk = account[2]
			password = account[3]
			f_id = account[4]
			self.result.emit(row, f"Th·ª±c Hi·ªán R√∫t ƒêi·ªÉm")
			headers = {
				"accept": "application/json, text/plain, */*",
				"content-type": "application/json",
				"f-id": f_id,
				"locale": "vi_vn",
				"referer": "https://m.oklavip26.live/wallet?type=0",
				"token": token,
				"user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
			}

			password = hashlib.md5(self.game_phone.encode('utf-8')).hexdigest()
			data = {
				"withdrawPoint":  self.game_account,
				"withdrawPassword": password,
				"websiteId": self.game_info["id"],
				"memberCode": self.game_info["memberCode"]
			}
			try:
				proxies = create_proxy(proxy)
				response = requests.post(
					"https://m.oklavip26.live/api/withdrawRecord/withdraw",
					headers=headers,
					json=data,
					proxies=proxies,
					timeout=1
				)
				self.result.emit(row, f"‚úÖ {response.status_code} - {response.text}")
			except Exception as e:
				self.result.emit(row, f"‚úÖ ƒê√£ Th·ª±c Hi·ªán L·ªánh")
	def show_context_menu(self, pos):
		import threading

		index = self.table.indexAt(pos)
		if not index.isValid():
			return

		menu = QMenu(self)

		# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ T∆Ø∆†NG T√ÅC T√ÄI KHO·∫¢N ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
		menu.addSection("üë§ T√†i kho·∫£n")
		add_note = menu.addAction("üìù Th√™m ghi ch√∫")
		load_accounts = menu.addAction("üìÇ Load File ACC")
		open_profile = menu.addAction("üßë‚Äçüíª M·ªü Profile")
		set_pin = menu.addAction("üîê Set m√£ PIN r√∫t ti·ªÅn")
		delete_banned = menu.addAction("üóëÔ∏è X√≥a t√†i kho·∫£n b·ªã c·∫•m")
		menu.addSeparator()

		# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LI√äN K·∫æT & TOKEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
		menu.addSection("üîó Token & Li√™n k·∫øt")
		get_token = menu.addAction("üîê Get Token")
		refresh_token = menu.addAction("‚ôªÔ∏è L·∫•y l·∫°i Token ch·∫øt")
		auto_link = menu.addAction("[Hot] üöÄ T·ª± ƒë·ªông li√™n k·∫øt + l·∫•y ƒëi·ªÉm + ƒêƒÉng Nh·∫≠p")
		custom_link = menu.addAction("üõ†Ô∏è Li√™n k·∫øt t√πy ch·ªçn")
		manual_link = menu.addAction("‚úçÔ∏è Li√™n k·∫øt th·ªß c√¥ng")
		menu.addSeparator()

		# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NHI·ªÜM V·ª§ & ƒêI·ªÇM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
		menu.addSection("üéØ Nhi·ªám v·ª•")
		get_points = menu.addAction("üí∞ L·∫•y ƒëi·ªÉm")
		check_in = menu.addAction("üìÖ ƒêi·ªÉm danh")
		run_all = menu.addAction("[Hot] ‚öôÔ∏è Ch·∫°y t·∫•t c·∫£")
		withdraw_points = menu.addAction("üí∏ R√∫t ƒëi·ªÉm")
		menu.addSeparator()

		# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ KI·ªÇM TRA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
		menu.addSection("üîé Ki·ªÉm tra")
		check_answers = menu.addAction("‚ùì Ki·ªÉm tra l∆∞·ª£t tr·∫£ l·ªùi")
		check_words = menu.addAction("üß© Ki·ªÉm tra gh√©p ch·ªØ")
		check_links = menu.addAction("üîó Ki·ªÉm tra li√™n k·∫øt")
		check_proxy = menu.addAction("[Hot] üåê Ki·ªÉm tra proxy")

		# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ X·ª¨ L√ù S·ª∞ KI·ªÜN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
		action = menu.exec(self.table.viewport().mapToGlobal(pos))

		if action == add_note:
			row = self.table.currentRow()
			note, ok = QInputDialog.getText(self, "Th√™m ghi ch√∫", "Nh·∫≠p ghi ch√∫:")
			if ok:
				self.table.setItem(row, 7, QTableWidgetItem(note))
				self.save_accounts_to_file()

		elif action == load_accounts:
			self.load_accounts_from_file()

		elif action == open_profile:
			row = self.table.currentRow()
			threading.Thread(target=lambda: self.MoProfileTheoTenUser(row)).start()

		elif action == set_pin:
			row = self.table.currentRow()
			threading.Thread(target=lambda: self.SetMaPinChoTaiKhoan(row)).start()

		elif action == get_token:
			threading.Thread(target=self.TokenGet).start()

		elif action == refresh_token:
			threading.Thread(target=self.LayLaiTokenChoTokenChetttt).start()

		elif action == auto_link:
			threading.Thread(target=self.lienkettaikhoan).start()

		elif action == custom_link:
			self.LienKetTuyChon()

		elif action == manual_link:
			threading.Thread(target=self.LienKetThuCong).start()

		elif action == get_points:
			selected_rows = list({index.row() for index in self.table.selectedIndexes()})
			if selected_rows:
				threading.Thread(target=lambda: self.run_multiple_threads(selected_rows, self.spinbox.value())).start()

		elif action == check_in:
			threading.Thread(target=self.Bu9diem).start()

		elif action == run_all:
			threading.Thread(target=self.ChAyAll).start()

		elif action == withdraw_points:
			self.Thuanrutdiemday()

		elif action == check_answers:
			threading.Thread(target=self.CheckLuotTraLoi).start()

		elif action == check_words:
			threading.Thread(target=self.CheckGhepChu).start()

		elif action == check_links:
			threading.Thread(target=self.CheckCacLienKet).start()

		elif action == check_proxy:
			threading.Thread(target=self.CheckProxy).start()

		elif action == delete_banned:
			self.delete_banned_accounts()

	def LienKetThuCong(sedf):
		threading.Thread(target=self.LienKet).start()
		
	def LienKet(self):
		game_list = [
			{"memberCode": "MOCBAI", "websiteName": "MB66", "id": "1739230912039436290"},
			{"memberCode": "OK9", "websiteName": "OK9", "id": "1798608608416931842"},
			{"memberCode": "78win", "websiteName": "78win", "id": "1814571722874535937"},
			{"memberCode": "QQ88", "websiteName": "QQ88", "id": "1863085503318499329"},
			{"memberCode": "F168", "websiteName": "F168", "id": "1863085976314355713"},
		]

		dialog = GameInputDialog(game_list,'Li√™n K·∫øt T√†i Kho·∫£n')
		if dialog.exec():
			game_info = dialog.selected_game
			game_account = dialog.game_account
			game_phone = dialog.game_phone
		else:
			return

		selected_rows = list(set(index.row() for index in self.table.selectedIndexes()))
		
		self.thread = LienKetWorker(selected_rows, self.accounts, game_info, game_account, game_phone)
		self.thread.result.connect(self.handle_result)
		self.thread.start()



	def open_proxy_checker1(self):
		luong = threading.Thread(target=self.open_proxy_checker)
		luong.start()    
	def checkloginn(self):
		for row in range(self.table.rowCount()):
			try:
				token = self.table.item(row, 0).text()
				proxy=self.table.item(row, 1).text()
				Fidd=self.table.item(row, 4).text()
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				headers={
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": Fidd,
					"token": token,
					"cache-control": "no-cache",
					"pragma": "no-cache",
					"referer": "https://m.oklavip26.live/",
				}
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				responsediem=requests.get("https://m.oklavip26.live/api/wallet/getWallet",headers=headers, proxies=proxies , timeout=500).json()
				diem=responsediem['data']['integral']
				self.table.setItem(row, 5, QTableWidgetItem(f"{diem}"))
			except:pass
			self.table.setItem(row, 6, QTableWidgetItem(f"{responsediem}"))

	def CheckLoginssssss(self,row):
			try:
				token = self.table.item(row, 0).text()
				proxy=self.table.item(row, 1).text()
				Fidd=self.table.item(row, 4).text()
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				headers={
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": Fidd,
					"token": token,
					"cache-control": "no-cache",
					"pragma": "no-cache",
					"referer": "https://m.oklavip26.live/",
				}
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				responsediem=requests.get("https://m.oklavip26.live/api/wallet/getWallet",headers=headers, proxies=proxies , timeout=500).json()
				diem=responsediem['data']['integral']
				self.table.setItem(row, 5, QTableWidgetItem(f"{diem}"))
				return True
			except:
				return False



	
	def update_link_status(self, row, message, color):
		item = QTableWidgetItem(message)
		item.setForeground(QBrush(QColor(color)))
		self.table.setItem(row, 6, item)

	def lienkettaikhoan(self):
		from concurrent.futures import ThreadPoolExecutor

		def start_worker(row):
			worker = LienKetWorker(self.accounts, row, self.CheckLoginssssss, self.table)  # ‚úÖ ƒë√£ th√™m self.table
			worker.result_signal.connect(self.update_link_status)
			worker.start()
			self.threads.append(worker)


		with ThreadPoolExecutor(max_workers=20) as executor:
			for row in range(self.table.rowCount()):
				executor.submit(start_worker, row)
   

	def MoProfileTheoTenUser(self, row):
		username = self.table.item(row, 2).text().strip()
		proxy = self.table.item(row, 1).text().strip()
		token = self.table.item(row, 0).text().strip()
		f_id = self.table.item(row, 4).text().strip()

		# Step 1: GET list profile
		response = requests.get("http://127.0.0.1:19995/api/v3/profiles?per_page=100000", timeout=10).json()
		if not response.get("success"):
			self.table.setItem(row, 6, QTableWidgetItem("‚ùå API profile l·ªói"))
			return

		profiles = response["data"]
		matched = next((p for p in profiles if p["name"].strip().lower() == username.lower()), None)

		if not matched:
			self.table.setItem(row, 6, QTableWidgetItem("‚ùå Kh√¥ng t√¨m th·∫•y profile"))
			headers = {
			"Content-Type": "application/json"
			}
			data = {
				"profile_name": f"{username}",
			}
			ID = requests.post(f"http://127.0.0.1:19995/api/v3/profiles/create", json=data,headers=headers).json()['data']['id']
			response = requests.get("http://127.0.0.1:19995/api/v3/profiles?per_page=100000", timeout=10).json()
			if not response.get("success"):
				self.table.setItem(row, 6, QTableWidgetItem("‚ùå API profile l·ªói"))
				return

			profiles = response["data"]
			matched = next((p for p in profiles if p["name"].strip().lower() == username.lower()), None)
		profile_id = matched["id"]
		headers = {
		"Content-Type": "application/json"
		}
		data = {
			"profile_name": username,
			"raw_proxy": f"{proxy}",
			"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36"
		}
		res = requests.post(f"http://127.0.0.1:19995/api/v3/profiles/update/{profile_id}", json=data,headers=headers)
		print("Status:", res.status_code)
		# Step 2: Start profile and get debug address
		url = f"http://127.0.0.1:19995/api/v3/profiles/start/{profile_id}"
		json_data = requests.get(url).json()
		remote_debugging_address = json_data["data"]["remote_debugging_address"]
		driver_path = json_data["data"]["driver_path"]
		options = webdriver.ChromeOptions()
		options.debugger_address = remote_debugging_address
		service = Service(driver_path)
		driver = webdriver.Chrome(service=service, options=options)

		driver.get("https://m.oklavip26.live")

		# ƒê·ª¢I DOM S·∫¥N S√ÄNG
		WebDriverWait(driver, 15).until(
			lambda d: d.execute_script("return document.readyState") == "complete"
		)

		# INJECT LOCAL STORAGE
		script = f'''
			window.localStorage.setItem("token", "{token}");
		'''
		driver.execute_script(script)
		script = f'''
			window.localStorage.setItem("F-Id", "{f_id}");
		'''
		driver.execute_script(script)

		# LOAD L·∫†I ƒê·ªÇ √ÅP D·ª§NG
		driver.get("https://m.oklavip26.live")

		self.table.setItem(row, 6, QTableWidgetItem("‚úÖ ƒê√£ set localStorage v√† m·ªü okvip18.live"))

	  



	def Bu9diem(self):
		from concurrent.futures import ThreadPoolExecutor, as_completed
		def chay_20_mot_luot():
			def xu_ly_row(row):
				token = self.table.item(row, 0).text()
				proxy=self.table.item(row, 1).text()
				Fidd=self.table.item(row, 4).text()
				url = "https://m.oklavip26.live/api/activitySignIn/singIn"

				headers = {
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"referer": "https://m.oklavip26.live/login",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": Fidd,
					"token": token
				}
				self.table.setItem(row, 6, QTableWidgetItem(f"ƒêi·ªÉm Danhhhhhhhhhhhhhhh"))

				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}

				chechDangNhap=self.CheckLoginssssss(row)
				print(chechDangNhap)
				if chechDangNhap:
					response = requests.post(url, headers=headers, proxies=proxies ,timeout=500)
					print(response.text)
					aaaaaaaaaaaa=response.json()["data"]["continueDays"]
					response = requests.get("https://m.oklavip26.live/api/accountLogin/updateOnline", headers=headers, proxies=proxies ,timeout=500)
				   
					self.table.setItem(row, 6, QTableWidgetItem(f"‚úÖ ƒê√£ ƒêi·ªÉm Danh Th√†nh C√¥ng: {aaaaaaaaaaaa}"))
					try:
						aaaaaaaaaaaa=int(aaaaaaaaaaaa)
						current_date = QDate.currentDate()
						formatted_date = current_date.toString("dd/MM")
						self.table.setItem(row, 8, QTableWidgetItem(formatted_date+f"[{aaaaaaaaaaaa}]"))

					except:pass
				else:
					self.table.setItem(row, 6, QTableWidgetItem(f"[üí©]> Token Ch·∫øt M·∫∏ R·ªìi em! <[üí©]"))
			   

			with ThreadPoolExecutor(max_workers=50) as executor:
				futures = [executor.submit(xu_ly_row, row) for row in range(self.table.rowCount())]
				for future in as_completed(futures):
					pass  # b·∫°n c√≥ th·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£ ho·∫∑c log t·∫°i ƒë√¢y n·∫øu c·∫ßn
		chay_20_mot_luot() 
	def CheckCacLienKet(self):
		from concurrent.futures import ThreadPoolExecutor, as_completed
		def chay_20_mot_luot():
			def xu_ly_row(row):
				token = self.table.item(row, 0).text()
				proxy=self.table.item(row, 1).text()
				Fidd=self.table.item(row, 4).text()
				self.table.setItem(row, 6, QTableWidgetItem(f"[XXX] Ki·ªÉm Tra Proxy!"))

				headers = {
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"referer": "https://m.oklavip26.live/login",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": Fidd,
					"token": token
				}
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				response = requests.get("https://m.oklavip26.live/api/website/listForWallet", headers=headers, proxies=proxies, timeout=500).json()
			   # L·∫•y c√°c gi√° tr·ªã isBind t·ª´ response
				MB66 = response['data'][0]["isBind"]
				OK9 = response['data'][1]["isBind"]
				s78win = response['data'][2]["isBind"]
				QQ88 = response['data'][3]["isBind"]
				F168 = response['data'][4]["isBind"]

				# T·∫°o danh s√°ch t√™n ·ª©ng v·ªõi gi√° tr·ªã True
				bindings = []
				if MB66:pass
				else: bindings.append("MB66")
				if OK9:pass
				else: bindings.append("OK9")
				if s78win:pass
				else: bindings.append("78win")
				if QQ88:pass
				else: bindings.append("QQ88")
				if F168:pass
				else: bindings.append("F168")

				# Hi·ªÉn th·ªã chu·ªói k·∫øt qu·∫£, ngƒÉn c√°ch b·∫±ng " | "
				result_text = " ".join(bindings)

				# Hi·ªÉn th·ªã trong b·∫£ng
				self.table.setItem(row, 7, QTableWidgetItem(result_text))

				self.table.setItem(row, 6, QTableWidgetItem(f"[OK] Ho√†n Th√†nh L·∫•y Li√™n K·∫øt"))

			with ThreadPoolExecutor(max_workers=50) as executor:
				futures = [executor.submit(xu_ly_row, row) for row in range(self.table.rowCount())]
				for future in as_completed(futures):
					pass  # b·∫°n c√≥ th·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£ ho·∫∑c log t·∫°i ƒë√¢y n·∫øu c·∫ßn
		chay_20_mot_luot()    
	def CheckProxy(self):
		from concurrent.futures import ThreadPoolExecutor, as_completed
		def chay_20_mot_luot():
			def xu_ly_row(row):
				proxy=self.table.item(row, 1).text()
				self.table.setItem(row, 6, QTableWidgetItem(f"[XXX] Ki·ªÉm Tra M·∫°ng M√°y!"))
				def kiem_tra_mang():
					for lan in range(3):
						try:
							requests.get("https://www.google.com", timeout=10)
							return True
						except requests.RequestException:
							self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå M√°y t√≠nh kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng. Th·ª≠ l·∫°i l·∫ßn {lan + 1}"))
					return False

				def kiem_tra_proxy(proxy_str):
					ip, port, user, password = proxy_str.split(":")
					proxy_url = f"http://{user}:{password}@{ip}:{port}"

					proxies = {
						"http": proxy_url,
						"https": proxy_url
					}

					try:
						response = requests.get("https://geo.myip.link/", proxies=proxies, timeout=10)
						if response.status_code == 200:
							return True, response.json()
						else:
							return False, f"L·ªói m√£ tr·∫°ng th√°i HTTP: {response.status_code}"
					except requests.RequestException as e:
						return False, str(e)

				# G·ªçi h√†m ki·ªÉm tra
				if kiem_tra_mang():
					self.table.setItem(row, 6, QTableWidgetItem(f"‚úÖ M·∫°ng ho·∫°t ƒë·ªông."))
					thanh_cong, ket_qua = kiem_tra_proxy(proxy)
					if thanh_cong:
						self.table.setItem(row, 6, QTableWidgetItem(f"‚úÖ Proxy ho·∫°t ƒë·ªông. "))
						print(ket_qua)
					else:
						self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå Proxy kh√¥ng ho·∫°t ƒë·ªông. "))
						print(ket_qua)
				else:
					print("")
					self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå M√°y t√≠nh kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng."))



			with ThreadPoolExecutor(max_workers=99) as executor:
				futures = [executor.submit(xu_ly_row, row) for row in range(self.table.rowCount())]
				for future in as_completed(futures):
					pass  # b·∫°n c√≥ th·ªÉ x·ª≠ l√Ω k·∫øt qu·∫£ ho·∫∑c log t·∫°i ƒë√¢y n·∫øu c·∫ßn
		chay_20_mot_luot()    
	def ChAyAll(self):
		from concurrent.futures import ThreadPoolExecutor, as_completed
		def chay_20_mot_luot():
			def xu_ly_row(row):
				try:
					self.table.setItem(row, 6, QTableWidgetItem(f"B·∫Øt ƒê·∫ßu"))
					self.table.setItem(row, 6, QTableWidgetItem(f"Check Token"))

					chechDangNhap=self.CheckLoginssssss(row)
					print(chechDangNhap)
					if chechDangNhap:
						self.table.setItem(row, 6, QTableWidgetItem(f"B·∫Øt Tr·∫£ L·ªùi C√¢u H·ªèi"))
						self.CheckLuotTraLoiall(row)
						self.table.setItem(row, 6, QTableWidgetItem(f"B·∫Øt Quay Ch·ªØ"))
						self.CheckGhepChuall(row)
						self.table.setItem(row, 6, QTableWidgetItem(f"‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è"))
					else:
						self.table.setItem(row, 6, QTableWidgetItem(f"[üí©üí©üí©]> Token Ch·∫øt M·∫∏ R·ªìi em!"))
				except:
					self.table.setItem(row, 6, QTableWidgetItem(f"[üí©üí©üí©]> L·ªói C√°i Ch√≥ G√¨ √Å T·ª± Check !"))

			# ƒê·ªçc file tool_key.json v√† l·∫•y gi√° tr·ªã threads
			with open("tool_key.json", "r", encoding="utf-8") as f:
				data = json.load(f)

			if "threads" not in data:
				raise ValueError("Kh√¥ng t√¨m th·∫•y 'threads' trong file tool_key.json")

			so_luong_luong = data["threads"]

			with ThreadPoolExecutor(max_workers=so_luong_luong) as executor:
				futures = [executor.submit(xu_ly_row, row) for row in range(self.table.rowCount())]
				for future in as_completed(futures):
					pass  # x·ª≠ l√Ω k·∫øt qu·∫£ n·∫øu c·∫ßn
		chay_20_mot_luot()
	
	def TokenGetsl(self):
		def login_to_account(account, passwordf, proxy,f_id):
			proxy_url, port, username, password = proxy.split(':')
			proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
			proxies = {
				"http": proxy_address,
				"https": proxy_address
			}
			import requests
			import random
			import hashlib
			import json
			import time
			import concurrent.futures
			import re
			
			uuid, code = get_captcha_text(proxies)
			md5_hash = hashlib.md5()
			md5_hash.update(passwordf.encode('utf-8'))
			passwordf = md5_hash.hexdigest()
			print(uuid, code)
			url = "https://m.oklavip26.live/api/accountLogin/doLogin"
			headers = {
				"authority": "m.oklavip26.live",
				"accept": "application/json, text/plain, */*",
				"accept-language": "vi-VN,vi;q=0.9",
				"content-type": "application/json",
				"locale": "vi_vn",
				"origin": "https://m.oklavip26.live",
				"priority": "u=1, i",
				"referer": "https://m.oklavip26.live/login",
				"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
				"sec-ch-ua-mobile": "?0",
				"sec-ch-ua-platform": "Windows",
				"sec-fetch-dest": "empty",
				"sec-fetch-mode": "cors",
				"sec-fetch-site": "same-origin",
				"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
				"f-id": f_id
			}
			data = {
				"account": account,
				"password": passwordf,
				"code": code,
				"uuid": uuid,
				"device": "H5"
			}

			# N·∫øu proxy kh√¥ng ph·∫£i l√† None, th√™m v√†o tham s·ªë proxies
			if proxy:
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				response = requests.post(url, headers=headers, json=data, proxies=proxies ,timeout=20)
			else:
				response = requests.post(url, headers=headers, json=data,timeout=20)
			print(response.text)
			# Ki·ªÉm tra ph·∫£n h·ªìi
			if response.json()['message'] == 'Thao t√°c th√†nh c√¥ng':
				token = response.json()['data']['token']
				return f'{token}'
			elif response.json()['message'] == 'M√£ x√°c nh·∫≠n sai':
				login_to_account(account, password, proxy,f_id)
			else:
				return None
		def kiem_tra_ky_tu(chuoi):
			return not re.match("^[a-zA-Z0-9]+$", chuoi)
		def get_captcha_text(proxies):
			solan = 0
			text = ""
			while len(text) < 4 or kiem_tra_ky_tu(text):
				solan += 1
				if solan >= 2:
					try:IMG = requests.get("https://m.oklavip26.live/api/accountLogin/captcha", proxies=proxies ,timeout=20).json()
					except:pass
					solan = 0
				try:
					IMG = requests.get("https://m.oklavip26.live/api/accountLogin/captcha", proxies=proxies ,timeout=20).json()
					img_src = IMG['data']['image']
					uuid = IMG['data']['uuid']
					url = "http://103.77.242.210:8000/ocr"
					headers = {"accept": "application/json"}
					data = {"image": img_src}
					response = requests.post(url, headers=headers, data=data,timeout=20)
					print(response.json()['data'])
					text=response.json()['data']
				except:pass
				print("captcha: ",text)
			return uuid,text
		def LayToken(account, password, proxy,f_id):
			return login_to_account(account, password, proxy,f_id)
		for row in range(self.table.rowCount()):
			token = self.table.item(row, 0).text()
			proxy=self.table.item(row, 1).text()
			Taikhoan=self.table.item(row, 2).text()
			Matkhau=self.table.item(row, 3).text()
			Fidd=self.table.item(row, 4).text()
			tokennew=LayToken(Taikhoan, Matkhau, proxy,Fidd)
			self.table.setItem(row, 0, QTableWidgetItem(f"{tokennew}"))
			self.table.setItem(row, 6, QTableWidgetItem(f"ƒê√£ L·∫•y Token M·ªõi"))
			time.sleep(3)

	 

			
	def TokenGet(self):
		selected_row = self.table.currentRow()
		selected_rows = [index.row() for index in self.table.selectedIndexes()]
		for row in selected_rows:
			account = self.accounts[row]
			token = account[0]
			proxy = account[1]
			password = account[3]
			tkkk = account[2]
			print(row)
			f_id = account[4]
			self.table.setItem(row, 6, QTableWidgetItem("B·∫Øt ƒë·∫ßu ki·ªÉm tra"))
			print(token,account,proxy,f_id)
			def login_to_account(account, passwordf, proxy,f_id):
				passwordfcc=passwordf
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {
					"http": proxy_address,
					"https": proxy_address
				}
				print(passwordf)
				uuid, code = get_captcha_text(proxies)
				md5_hash = hashlib.md5()
				md5_hash.update(passwordf.encode('utf-8'))
				passwordf = md5_hash.hexdigest()
				print(uuid, code,passwordf)
				url = "https://m.oklavip26.live/api/accountLogin/doLogin"
				headers = {
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"referer": "https://m.oklavip26.live/login",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": f_id
				}
				data = {
					"account": account,
					"password": passwordf,
					"code": code,
					"uuid": uuid,
					"device": "H5"
				}

				# N·∫øu proxy kh√¥ng ph·∫£i l√† None, th√™m v√†o tham s·ªë proxies
				if proxy:
					proxy_url, port, username, password = proxy.split(':')
					proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
					proxies = {
						"http": proxy_address,
						"https": proxy_address
					}
					response = requests.post(url, headers=headers, json=data, proxies=proxies ,timeout=500)
				else:
					response = requests.post(url, headers=headers, json=data,timeout=500)
				print(response.text)
				# Ki·ªÉm tra ph·∫£n h·ªìi
				if response.json()['message'] == 'Thao t√°c th√†nh c√¥ng':
					token = response.json()['data']['token']
					return f'{token}|{proxy}|{account}|{passwordfcc}|{f_id}'
				elif response.json()['message'] == 'M√£ x√°c nh·∫≠n sai':
					login_to_account(account, password, proxy,f_id)
				else:
					return None
			def kiem_tra_ky_tu(chuoi):
				return not re.match("^[a-zA-Z0-9]+$", chuoi)
			def get_captcha_text(proxies):
				solan = 0
				text = ""
				while len(text) < 4 or kiem_tra_ky_tu(text):
					IMG = requests.get("https://m.oklavip26.live/api/accountLogin/captcha", proxies=proxies ,timeout=500).json()
					solan += 1
					if solan >= 5:
						try:
							IMG = requests.get("https://m.oklavip26.live/api/accountLogin/captcha", proxies=proxies ,timeout=500).json()
						except:
							pass
						solan = 0

					try:

						IMG = requests.get("https://m.oklavip26.live/api/accountLogin/captcha", proxies=proxies ,timeout=500).json()

						img_src = IMG['data']['image']
						uuid = IMG['data']['uuid']
						url = "http://103.77.242.210:8000/ocr"
						headers = {"accept": "application/json"}
						data = {"image": img_src}

						response = requests.post(url, headers=headers, data=data,timeout=500)
						print(response.json()['data'])
						text=response.json()['data']
					except:
						time.sleep(1)
					print(text)
				return uuid,text
		aaa=login_to_account(tkkk,password,proxy,f_id)
		def thay_doi_dong(file_path, dong_muon_thay, noi_dung_moi):
			try:
				with open(file_path, 'r', encoding='utf-8') as file:
					lines = file.readlines()

				if dong_muon_thay < 1 or dong_muon_thay > len(lines):
					print(f"D√≤ng {dong_muon_thay} kh√¥ng t·ªìn t·∫°i trong t·ªáp.")
					return

				lines[dong_muon_thay - 1] = noi_dung_moi + '\n'

				with open(file_path, 'w', encoding='utf-8') as file:
					file.writelines(lines)
				self.table.setItem(selected_row, 0, QTableWidgetItem(f"{noi_dung_moi}"))

				print(f"ƒê√£ thay ƒë·ªïi d√≤ng {dong_muon_thay} th√†nh: {noi_dung_moi}")
				self.save_accounts_to_file()
			except FileNotFoundError:
				print(f"T·ªáp {file_path} kh√¥ng t·ªìn t·∫°i.")

		thay_doi_dong("ACC.txt", row+1, f"{aaa}")
		self.load_accounts_from_file()
	def CheckLuotTraLoiall(self,selected_row):
		row=selected_row
		import random
		def lay_answer_list():
			if not hasattr(lay_answer_list, "shuffled_answers") or lay_answer_list.index >= len(lay_answer_list.shuffled_answers):
				# G·ªôp to√†n b·ªô 15 c√¢u
				all_answers = [
					{"id":"1813068590722039810","submitAnswer":"B"},
					{"id":"1885293145245704194","submitAnswer":"D"},
					{"id":"1813055126444163073","submitAnswer":"B"},
					{"id":"1758663639615070209","submitAnswer":"D"},
					{"id":"1785300906974543873","submitAnswer":"B"},
					{"id":"1832001421560930305","submitAnswer":"C"},
					{"id":"1862969516842795009","submitAnswer":"A"},
					{"id":"1813061385461415937","submitAnswer":"C"},
					{"id":"1852195947499892738","submitAnswer":"C"},
					{"id":"1845597110031245313","submitAnswer":"A"},
					{"id":"1852198018005479426","submitAnswer":"B"},
					{"id":"1785310696345862145","submitAnswer":"B"},
					{"id":"1785286596449697793","submitAnswer":"D"},
					{"id":"1742430977931452417","submitAnswer":"D"},
					{"id":"1839964599813079042","submitAnswer":"D"},
					{"id":"1854143870443585537","submitAnswer":"D"},
					{"id":"1785518438150995969","submitAnswer":"B"},
					{"id":"1824048832353558530","submitAnswer":"C"},
					{"id":"1832922633518604290","submitAnswer":"A"},
					{"id":"1845605186754994177","submitAnswer":"A"},
					{"id":"1910234836605042689","submitAnswer":"C"},
					{"id":"1743642787544043521","submitAnswer":"C"},
					{"id":"1839623537886142465","submitAnswer":"B"},
					{"id":"1857079383320297474","submitAnswer":"B"},
					{"id":"1758729048947089409","submitAnswer":"D"},
					{"id":"1913734370549690370","submitAnswer":"A"},
					{"id":"1790399254207328258","submitAnswer":"A"},
					{"id":"1758658110029225986","submitAnswer":"B"},
					{"id":"1857079675314675714","submitAnswer":"C"},
					{"id":"1906204991478239234","submitAnswer":"B"},
					{"id":"1813068590722039810","submitAnswer":"B"},
					{"id":"1758661648285360129","submitAnswer":"C"},
					{"id":"1900874100297801729","submitAnswer":"A"},
					{"id":"1785309013456879617","submitAnswer":"A"}

				]
				random.shuffle(all_answers)  # Tr·ªôn k·ªπ m·ªói l·∫ßn l√†m m·ªõi
				lay_answer_list.shuffled_answers = all_answers
				lay_answer_list.index = 0

			# L·∫•y 5 c√¢u li√™n ti·∫øp
			start = lay_answer_list.index
			end = start + 5
			result = lay_answer_list.shuffled_answers[start:end]
			lay_answer_list.index += 5
			return result

		
		account = self.accounts[row]
		token = account[0]
		proxy = account[1]
		f_id = account[4]
		self.table.setItem(row, 6, QTableWidgetItem("B·∫Øt ƒë·∫ßu ki·ªÉm tra"))
		try:
			proxy_url, port, username, password = proxy.split(':')
			proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
			proxies = {"http": proxy_address, "https": proxy_address}
			headers = {
				"authority": "m.oklavip26.live",
				"accept": "application/json, text/plain, */*",
				"accept-language": "vi-VN,vi;q=0.9",
				"content-type": "application/json",
				"locale": "vi_vn",
				"origin": "https://m.oklavip26.live",
				"priority": "u=1, i",
				"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
				"sec-ch-ua-mobile": "?0",
				"sec-ch-ua-platform": "Windows",
				"sec-fetch-dest": "empty",
				"sec-fetch-mode": "cors",
				"sec-fetch-site": "same-origin",
				"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
				"f-id": f_id,
				"token": token,
				"cache-control": "no-cache",
				"pragma": "no-cache",
				"referer": "https://m.oklavip26.live/",
			}
			response = requests.get(
				"https://m.oklavip26.live/api/activityQuestion/getActivityQuestionInfo",
				headers=headers, proxies=proxies, timeout=500).json()
			luot = response['data']['surplusNumber']
			self.table.setItem(row, 6, QTableWidgetItem(f"C√≤n {luot} l∆∞·ª£t"))
			account[6] = f"C√≤n {luot} l∆∞·ª£t"
			self.update_log(f"{account[2]} c√≤n {luot} l∆∞·ª£t tr·∫£ l·ªùi.")
			for cac in range(int(luot)):
				DanhSachCauHoi = requests.get('https://m.oklavip26.live/api/activityQuestion/getQuestionList',headers=headers, proxies=proxies, timeout=500).json()['data']
				delay_time = random.randint(20, 35)
				for delay in range(delay_time, -1, -1):
					self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay}"))
					time.sleep(1)
				date_time = int(time.time())
				recordNo = requests.get('https://m.oklavip26.live/api/activityQuestion/startAnswerQuestion',headers=headers, proxies=proxies, timeout=500).json()['data']['recordNo']
				dataTraloi = {
					"answerList": lay_answer_list(),
					"timeStart": date_time,
					"recordNo": recordNo
				}
				response = requests.post('https://m.oklavip26.live/api/activityQuestion/submitQuestion',headers=headers,json=dataTraloi, proxies=proxies, timeout=500)
				print(response.json())
				time.sleep(3)
			print("Kimochi")
			CheckLuotQuay=requests.get("https://m.oklavip26.live/api/lottery/getLuckyDrawBaseInfo",headers=headers , proxies=proxies , timeout=500).json()
			data2 = {"raffleId": CheckLuotQuay['data']['raffleId']}
			CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/getLuckyDrawInfoByDaily",headers=headers , proxies=proxies , timeout=500).json()['data']['drawCount']
			print(CheckLuotQuay)
			for xx in range(int(CheckLuotQuay)):
				CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/lotteryByDaily",headers=headers, json=data2 , proxies=proxies , timeout=500).json()
				delay_time = random.randint(5,6)
				for delay in range(delay_time, -1, -1):
					self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{CheckLuotQuay["data"]['prizeInfo']['prizeName']}]"))
					time.sleep(1)
			self.table.setItem(selected_row, 6, QTableWidgetItem(f"Xong!"))

		except Exception as e:
			self.update_log(f"L·ªói ki·ªÉm tra l∆∞·ª£t:")
	def CheckLuotTraLoi(self):
		selected_row = self.table.currentRow()
		import random
		def lay_answer_list():
			if not hasattr(lay_answer_list, "shuffled_answers") or lay_answer_list.index >= len(lay_answer_list.shuffled_answers):
				# G·ªôp to√†n b·ªô 15 c√¢u
				all_answers = [
					{"id":"1813068590722039810","submitAnswer":"B"},
					{"id":"1885293145245704194","submitAnswer":"D"},
					{"id":"1813055126444163073","submitAnswer":"B"},
					{"id":"1758663639615070209","submitAnswer":"D"},
					{"id":"1785300906974543873","submitAnswer":"B"},
					{"id":"1832001421560930305","submitAnswer":"C"},
					{"id":"1862969516842795009","submitAnswer":"A"},
					{"id":"1813061385461415937","submitAnswer":"C"},
					{"id":"1852195947499892738","submitAnswer":"C"},
					{"id":"1845597110031245313","submitAnswer":"A"},
					{"id":"1852198018005479426","submitAnswer":"B"},
					{"id":"1785310696345862145","submitAnswer":"B"},
					{"id":"1785286596449697793","submitAnswer":"D"},
					{"id":"1742430977931452417","submitAnswer":"D"},
					{"id":"1839964599813079042","submitAnswer":"D"},
					{"id":"1854143870443585537","submitAnswer":"D"},
					{"id":"1785518438150995969","submitAnswer":"B"},
					{"id":"1824048832353558530","submitAnswer":"C"},
					{"id":"1832922633518604290","submitAnswer":"A"},
					{"id":"1845605186754994177","submitAnswer":"A"},
					{"id":"1910234836605042689","submitAnswer":"C"},
					{"id":"1743642787544043521","submitAnswer":"C"},
					{"id":"1839623537886142465","submitAnswer":"B"},
					{"id":"1857079383320297474","submitAnswer":"B"},
					{"id":"1758729048947089409","submitAnswer":"D"},
					{"id":"1913734370549690370","submitAnswer":"A"},
					{"id":"1790399254207328258","submitAnswer":"A"},
					{"id":"1758658110029225986","submitAnswer":"B"},
					{"id":"1857079675314675714","submitAnswer":"C"},
					{"id":"1906204991478239234","submitAnswer":"B"},
					{"id":"1813068590722039810","submitAnswer":"B"},
					{"id":"1758661648285360129","submitAnswer":"C"},
					{"id":"1900874100297801729","submitAnswer":"A"},
					{"id":"1785309013456879617","submitAnswer":"A"}

				]
				random.shuffle(all_answers)  # Tr·ªôn k·ªπ m·ªói l·∫ßn l√†m m·ªõi
				lay_answer_list.shuffled_answers = all_answers
				lay_answer_list.index = 0

			# L·∫•y 5 c√¢u li√™n ti·∫øp
			start = lay_answer_list.index
			end = start + 5
			result = lay_answer_list.shuffled_answers[start:end]
			lay_answer_list.index += 5
			return result

		selected_rows = [index.row() for index in self.table.selectedIndexes()]
		for row in selected_rows:
			account = self.accounts[row]
			token = account[0]
			proxy = account[1]
			f_id = account[4]
			self.table.setItem(row, 6, QTableWidgetItem("B·∫Øt ƒë·∫ßu ki·ªÉm tra"))
			try:
				proxy_url, port, username, password = proxy.split(':')
				proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
				proxies = {"http": proxy_address, "https": proxy_address}
				headers = {
					"authority": "m.oklavip26.live",
					"accept": "application/json, text/plain, */*",
					"accept-language": "vi-VN,vi;q=0.9",
					"content-type": "application/json",
					"locale": "vi_vn",
					"origin": "https://m.oklavip26.live",
					"priority": "u=1, i",
					"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
					"sec-ch-ua-mobile": "?0",
					"sec-ch-ua-platform": "Windows",
					"sec-fetch-dest": "empty",
					"sec-fetch-mode": "cors",
					"sec-fetch-site": "same-origin",
					"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
					"f-id": f_id,
					"token": token,
					"cache-control": "no-cache",
					"pragma": "no-cache",
					"referer": "https://m.oklavip26.live/",
				}
				response = requests.get(
					"https://m.oklavip26.live/api/activityQuestion/getActivityQuestionInfo",
					headers=headers, proxies=proxies, timeout=500).json()
				luot = response['data']['surplusNumber']
				self.table.setItem(row, 6, QTableWidgetItem(f"C√≤n {luot} l∆∞·ª£t"))
				account[6] = f"C√≤n {luot} l∆∞·ª£t"
				self.update_log(f"{account[2]} c√≤n {luot} l∆∞·ª£t tr·∫£ l·ªùi.")
				for cac in range(int(luot)):
					DanhSachCauHoi = requests.get('https://m.oklavip26.live/api/activityQuestion/getQuestionList',headers=headers, proxies=proxies, timeout=500).json()['data']
					delay_time = random.randint(20, 35)
					for delay in range(delay_time, -1, -1):
						self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay}"))
						time.sleep(1)
					date_time = int(time.time())
					recordNo = requests.get('https://m.oklavip26.live/api/activityQuestion/startAnswerQuestion',headers=headers, proxies=proxies, timeout=500).json()['data']['recordNo']
					dataTraloi = {
						"answerList": lay_answer_list(),
						"timeStart": date_time,
						"recordNo": recordNo
					}
					response = requests.post('https://m.oklavip26.live/api/activityQuestion/submitQuestion',headers=headers,json=dataTraloi, proxies=proxies, timeout=500)
					print(response.json())
					time.sleep(3)
				print("Kimochi")
				CheckLuotQuay=requests.get("https://m.oklavip26.live/api/lottery/getLuckyDrawBaseInfo",headers=headers , proxies=proxies , timeout=500).json()
				data2 = {"raffleId": CheckLuotQuay['data']['raffleId']}
				CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/getLuckyDrawInfoByDaily",headers=headers , proxies=proxies , timeout=500).json()['data']['drawCount']
				print(CheckLuotQuay)
				for xx in range(int(CheckLuotQuay)):
					CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/lotteryByDaily",headers=headers, json=data2 , proxies=proxies , timeout=500).json()
					delay_time = random.randint(5,6)
					for delay in range(delay_time, -1, -1):
						self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{CheckLuotQuay["data"]['prizeInfo']['prizeName']}]"))
						time.sleep(1)
				self.table.setItem(selected_row, 6, QTableWidgetItem(f"Xong!"))

			except Exception as e:
				self.update_log(f"L·ªói ki·ªÉm tra l∆∞·ª£t:")
	def CheckGhepChu(self):
		selected_row = self.table.currentRow()
		if selected_row < 0:
			return

		account = self.accounts[selected_row]
		token = account[0]
		proxy = account[1]
		f_id = account[4]

		proxy_url, port, username, password = proxy.split(':')
		proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
		proxies = {
			"http": proxy_address,
			"https": proxy_address
		}

		headers = {
			"authority": "m.oklavip26.live",
			"accept": "application/json, text/plain, */*",
			"accept-language": "vi-VN,vi;q=0.9",
			"content-type": "application/json",
			"locale": "vi_vn",
			"origin": "https://m.oklavip26.live",
			"priority": "u=1, i",
			"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
			"sec-ch-ua-mobile": "?0",
			"sec-ch-ua-platform": "Windows",
			"sec-fetch-dest": "empty",
			"sec-fetch-mode": "cors",
			"sec-fetch-site": "same-origin",
			"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
			"f-id": f_id,
			"token": token,
			"cache-control": "no-cache",
			"pragma": "no-cache",
			"referer": "https://m.oklavip26.live/",
		}

		try:
			response = requests.get('https://m.oklavip26.live/api/activityCollect/getListAvailable', headers=headers, proxies=proxies, timeout=500).json()
			idGame = response['data'][0]['id']
			data = {"id": idGame}
			draw_response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500).json()
			draw_times = draw_response['data']['drawTimes']
			status_text = f"L∆∞·ª£t gh√©p ch·ªØ c√≤n l·∫°i: {draw_times}"
			self.status_label.setText(status_text)
			self.table.setItem(selected_row, 6, QTableWidgetItem(status_text))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)
			for _ in range(int(draw_times)):
				response = requests.post('https://m.oklavip26.live/api/activityCollect/drawWord', headers=headers, json=data, proxies=proxies, timeout=500)
				print(response.text)
				for delay in range(5,-1,-1):
					self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response.json()["data"]['textName']}]"))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)
					time.sleep(1)
			response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500)
			synthesisTimes = response.json()['data']['synthesisTimes']
			data2 = {"raffleId": requests.get("https://m.oklavip26.live/api/activityCollect/getListAvailable", headers=headers, proxies=proxies, timeout=500).json()['data'][0]['lotteryId']}
			for _ in range(int(synthesisTimes)):
				response = requests.post('https://m.oklavip26.live/api/activityCollect/mergeWord', headers=headers, json=data, proxies=proxies, timeout=500)
				response2 = requests.post('https://m.oklavip26.live/api/lottery/lottery', headers=headers, json=data2, proxies=proxies, timeout=500)
				print(response2.text)
				for delay in range(5,-1,-1):
					self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response2.json()["data"]["prizeInfo"]["prizeName"]}]"))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)
					time.sleep(1)
			self.table.setItem(selected_row, 6, QTableWidgetItem(f"Gh√©p Ch·ªØ Ho√†n T·∫•t!"))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)

			account[6] = status_text  # C·∫≠p nh·∫≠t d·ªØ li·ªáu t√†i kho·∫£n n·∫øu c·∫ßn
			self.table.setItem(selected_row, 6, QTableWidgetItem(f"Gh√©p Ch·ªØ Ho√†n T·∫•t!!"))

		except Exception as e:
			error_text = f"L·ªói: {str(e)}"
			self.status_label.setText(error_text)
			self.table.setItem(selected_row, 6, QTableWidgetItem(error_text))  # C·∫≠p nh·∫≠t l·ªói v√†o Status

	def CheckGhepChuall(self,selected_row):
		row=selected_row

		account = self.accounts[selected_row]
		token = account[0]
		proxy = account[1]
		f_id = account[4]

		proxy_url, port, username, password = proxy.split(':')
		proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
		proxies = {
			"http": proxy_address,
			"https": proxy_address
		}

		headers = {
			"authority": "m.oklavip26.live",
			"accept": "application/json, text/plain, */*",
			"accept-language": "vi-VN,vi;q=0.9",
			"content-type": "application/json",
			"locale": "vi_vn",
			"origin": "https://m.oklavip26.live",
			"priority": "u=1, i",
			"sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
			"sec-ch-ua-mobile": "?0",
			"sec-ch-ua-platform": "Windows",
			"sec-fetch-dest": "empty",
			"sec-fetch-mode": "cors",
			"sec-fetch-site": "same-origin",
			"user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
			"f-id": f_id,
			"token": token,
			"cache-control": "no-cache",
			"pragma": "no-cache",
			"referer": "https://m.oklavip26.live/",
		}

		try:
			response = requests.get('https://m.oklavip26.live/api/activityCollect/getListAvailable', headers=headers, proxies=proxies, timeout=500).json()
			idGame = response['data'][0]['id']
			data = {"id": idGame}
			draw_response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500).json()
			draw_times = draw_response['data']['drawTimes']
			status_text = f"L∆∞·ª£t gh√©p ch·ªØ c√≤n l·∫°i: {draw_times}"
			self.status_label.setText(status_text)
			self.table.setItem(selected_row, 6, QTableWidgetItem(status_text))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)
			for _ in range(int(draw_times)):
				response = requests.post('https://m.oklavip26.live/api/activityCollect/drawWord', headers=headers, json=data, proxies=proxies, timeout=500)
				print(response.text)
				for delay in range(5,-1,-1):
					self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response.json()["data"]['textName']}]"))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)
					time.sleep(1)
			response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500)
			synthesisTimes = response.json()['data']['synthesisTimes']
			data2 = {"raffleId": requests.get("https://m.oklavip26.live/api/activityCollect/getListAvailable", headers=headers, proxies=proxies, timeout=500).json()['data'][0]['lotteryId']}
			for _ in range(int(synthesisTimes)):
				response = requests.post('https://m.oklavip26.live/api/activityCollect/mergeWord', headers=headers, json=data, proxies=proxies, timeout=500)
				response2 = requests.post('https://m.oklavip26.live/api/lottery/lottery', headers=headers, json=data2, proxies=proxies, timeout=500)
				print(response2.text)
				for delay in range(5,-1,-1):
					self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response2.json()["data"]["prizeInfo"]["prizeName"]}]"))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)
					time.sleep(1)
			self.table.setItem(selected_row, 6, QTableWidgetItem(f"Gh√©p Ch·ªØ Ho√†n T·∫•t!"))  # C·∫≠p nh·∫≠t c·ªôt Status (index = 3)

			account[6] = status_text  # C·∫≠p nh·∫≠t d·ªØ li·ªáu t√†i kho·∫£n n·∫øu c·∫ßn
			self.table.setItem(selected_row, 6, QTableWidgetItem(f"Gh√©p Ch·ªØ Ho√†n T·∫•t!!"))

		except Exception as e:
			error_text = f"L·ªói: {str(e)}"
			self.status_label.setText(error_text)
			self.table.setItem(selected_row, 6, QTableWidgetItem(error_text))  # C·∫≠p nh·∫≠t l·ªói v√†o Status


	def run_multiple_threads(self, selected_rows, num_threads):
		# Ensure we don't exceed the max threads from the key
		actual_threads = min(num_threads, self.max_threads)
		
		# Chia c√°c t√†i kho·∫£n ƒë√£ ch·ªçn th√†nh nh√≥m nh·ªè theo s·ªë l∆∞·ª£ng lu·ªìng
		chunks = [selected_rows[i:i + actual_threads] for i in range(0, len(selected_rows), actual_threads)]
		
		for chunk in chunks:
			worker = AccountWorker(self.accounts, chunk)
			worker.update_signal.connect(self.update_account_status)
			worker.log_signal.connect(self.update_log)
			worker.start()
			self.threads.append(worker)

	def update_account_status(self, row, points):
		self.table.setItem(row, 5, QTableWidgetItem(points))  # C·∫≠p nh·∫≠t ƒëi·ªÉm
		self.table.setItem(row, 6, QTableWidgetItem("Ho√†n th√†nh"))  # ƒê√°nh d·∫•u ho√†n th√†nh
		self.save_accounts_to_file()  # L∆∞u l·∫°i ƒëi·ªÉm sau khi c·∫≠p nh·∫≠t

	def update_log(self, log_message):
		self.log_label.setText(log_message)

	def contextMenuEvent(self, event):
		self.show_context_menu(event.pos())

	def LienKetTuyChon(self):
		if hasattr(self, "thuan_lienket_thread") and self.thuan_lienket_thread is not None and self.thuan_lienket_thread.isRunning():
			print("ƒêang ch·∫°y, vui l√≤ng ƒë·ª£i xong!")
			return
		game_list = [
			{"memberCode": "MOCBAI", "websiteName": "MB66", "id": "1739230912039436290"},
			{"memberCode": "OK9", "websiteName": "OK9", "id": "1798608608416931842"},
			{"memberCode": "78win", "websiteName": "78win", "id": "1814571722874535937"},
			{"memberCode": "QQ88", "websiteName": "QQ88", "id": "1863085503318499329"},
			{"memberCode": "F168", "websiteName": "F168", "id": "1863085976314355713"},
		]
		dialog = GameInputDialog(game_list,"Li√™n K·∫øt T√†i Kho·∫£n","User","S·ªë ƒêi·ªán Tho·∫°i")
		if dialog.exec():
			game_info = dialog.selected_game
			game_account = dialog.game_account
			game_phone = dialog.game_phone
		else:
			return
		selected_rows = [index.row() for index in self.table.selectedIndexes()]
		# N·∫øu ƒë√£ c√≥ thread c≈©, disconnect signal tr∆∞·ªõc khi t·∫°o m·ªõi
		if hasattr(self, "thuan_lienket_thread") and self.thuan_lienket_thread is not None:
			try:
				self.thuan_lienket_thread.result.disconnect(self.handle_lienket_tuychon_result)
			except Exception:
				pass
		self.thuan_lienket_thread = self.ThuanLienKet(selected_rows, self.accounts, game_info, game_account, game_phone)
		self.thuan_lienket_thread.result.connect(self.handle_lienket_tuychon_result)
		self.thuan_lienket_thread.start()

	def handle_lienket_tuychon_result(self, row, message):
		# C·∫≠p nh·∫≠t v√†o b·∫£ng n·∫øu mu·ªën, ho·∫∑c ch·ªâ log
		self.table.setItem(row, 6, QTableWidgetItem(message))
		print(f"[D√≤ng {row}] {message}")

	def load_tool_key(self):
		try:
			with open('tool_key.json', 'r', encoding='utf-8') as f:
				key_data = json.load(f)
				self.max_threads = key_data.get('threads', 20)  # Default to 20 if not specified
				self.expire_time = key_data.get('expire_time', 0)
				return True
		except Exception as e:
			print(f"Error loading tool key: {e}")
			return False

	def check_key_expiration(self):
		current_time = int(time.time())
		if current_time >= self.expire_time:
			QMessageBox.critical(self, "Key h·∫øt h·∫°n", "Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng gia h·∫°n ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng.")
			self.close()
			return False
		return True

	def start_expiration_check(self):
		self.expiration_timer = QTimer(self)
		self.expiration_timer.timeout.connect(self.check_key_expiration)
		self.expiration_timer.start(60000)  # Check every minute

	def start_countdown_timer(self):
		self.countdown_timer = QTimer(self)
		self.countdown_timer.timeout.connect(self.update_countdown)
		self.countdown_timer.start(1000)  # Update every second

	def update_countdown(self):
		current_time = int(time.time())
		remaining_time = self.expire_time - current_time
		
		if remaining_time <= 0:
			self.countdown_label.setText("Key ƒë√£ h·∫øt h·∫°n!")
			self.countdown_label.setStyleSheet("""
				QLabel {
					color: #ff0000;
					font-size: 14px;
					font-weight: bold;
					padding: 5px;
					background-color: #2b2b2b;
					border-radius: 5px;
				}
			""")
			self.close()
			return
		
		# Convert remaining time to hours, minutes, seconds
		hours = int(remaining_time // 3600)
		minutes = int((remaining_time % 3600) // 60)
		seconds = int(remaining_time % 60)
		
		# Format the countdown text
		countdown_text = f"Th·ªùi gian c√≤n l·∫°i: {hours:02d}:{minutes:02d}:{seconds:02d}"
		
		# Change color based on remaining time
		if remaining_time < 300:  # Less than 5 minutes
			color = "#ff0000"  # Red
		elif remaining_time < 1800:  # Less than 30 minutes
			color = "#ffa500"  # Orange
		else:
			color = "#00ff00"  # Green
		
		self.countdown_label.setStyleSheet(f"""
			QLabel {{
				color: {color};
				font-size: 14px;
				font-weight: bold;
				padding: 5px;
				background-color: #2b2b2b;
				border-radius: 5px;
			}}
		""")
		self.countdown_label.setText(countdown_text)

	def show_add_account_dialog(self):
		dialog = QDialog(self)
		dialog.setWindowTitle("Th√™m T√†i Kho·∫£n M·ªõi")
		dialog.setFixedWidth(400)
		dialog.setStyleSheet("""
			QDialog {
				background-color: #252526;
				color: white;
			}
			QLabel {
				color: white;
				font-size: 14px;
			}
			QLineEdit {
				padding: 8px;
				border: 1px solid #555;
				border-radius: 5px;
				background-color: #2b2b2b;
				color: white;
				font-size: 14px;
			}
			QPushButton {
				background-color: #4e4e4e;
				padding: 10px;
				border: none;
				border-radius: 5px;
				color: white;
				font-size: 14px;
			}
			QPushButton:hover {
				background-color: #5e5e5e;
			}
		""")

		layout = QVBoxLayout(dialog)

		# T·∫°o c√°c tr∆∞·ªùng nh·∫≠p li·ªáu
		fields = [
			("Token:", "token"),
			("Proxy:", "proxy"),
			("T√†i Kho·∫£n:", "username"),
			("M·∫≠t Kh·∫©u:", "password"),
			("M√£ Tr√¨nh Duy·ªát:", "f_id")
		]

		inputs = {}
		for label_text, field_name in fields:
			label = QLabel(label_text)
			input_field = QLineEdit()
			inputs[field_name] = input_field
			layout.addWidget(label)
			layout.addWidget(input_field)

		# N√∫t l∆∞u
		save_button = QPushButton("L∆∞u")
		save_button.clicked.connect(lambda: self.save_new_account(inputs, dialog))
		layout.addWidget(save_button)

		dialog.exec()

	def save_new_account(self, inputs, dialog):
		# L·∫•y gi√° tr·ªã t·ª´ c√°c tr∆∞·ªùng nh·∫≠p li·ªáu
		token = inputs["token"].text().strip() or ""  # N·∫øu token tr·ªëng th√¨ g√°n chu·ªói r·ªóng
		proxy = inputs["proxy"].text().strip()
		username = inputs["username"].text().strip()
		password = inputs["password"].text().strip()
		f_id = inputs["f_id"].text().strip()
		
		# Ki·ªÉm tra c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
		if not all([proxy, username, password, f_id]):
			QMessageBox.warning(dialog, "L·ªói", "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin!")
			return

		# T·∫°o d√≤ng m·ªõi v·ªõi token tr·ªëng
		new_line = f"{token}|{proxy}|{username}|{password}|{f_id}\n"

		# ƒê·ªçc n·ªôi dung file hi·ªán t·∫°i
		with open("ACC.txt", "r", encoding="utf-8") as f:
			existing_content = f.read()

		# Ghi n·ªôi dung m·ªõi v√†o ƒë·∫ßu file
		with open("ACC.txt", "w", encoding="utf-8") as f:
			f.write(new_line + existing_content)

		# Th√™m d√≤ng m·ªõi v√†o b·∫£ng
		row_position = self.table.rowCount()
		self.table.insertRow(row_position)
		
		# ƒê·∫£m b·∫£o b·∫£ng c√≥ ƒë·ªß c·ªôt
		if self.table.columnCount() < 5:
			self.table.setColumnCount(5)
			self.table.setHorizontalHeaderLabels(["Token", "Proxy", "Username", "Password", "F_ID"])
		
		# ƒêi·ªÅn th√¥ng tin v√†o c√°c c·ªôt t∆∞∆°ng ·ª©ng
		self.table.setItem(row_position, 0, QTableWidgetItem(token))  # Token (c√≥ th·ªÉ tr·ªëng)
		self.table.setItem(row_position, 1, QTableWidgetItem(proxy))
		self.table.setItem(row_position, 2, QTableWidgetItem(username))
		self.table.setItem(row_position, 3, QTableWidgetItem(password))
		self.table.setItem(row_position, 4, QTableWidgetItem(f_id))
		
		
		QMessageBox.information(dialog, "Th√†nh c√¥ng", "ƒê√£ th√™m t√†i kho·∫£n m·ªõi!")
		dialog.accept()

	def delete_banned_accounts(self):
		rows_to_delete = []
		for row in range(self.table.rowCount()):
			status_item = self.table.item(row, 6)
			if status_item and status_item.text() == "{'code': 50000, 'message': 'T√†i kho·∫£n ƒë√£ b·ªã c·∫•m d√πng', 'data': None}":
				rows_to_delete.append(row)
		
		# Delete rows in reverse order to avoid index shifting
		for row in sorted(rows_to_delete, reverse=True):
			self.table.removeRow(row)
			self.accounts.pop(row)
		
		self.save_accounts_to_file()
		self.log_label.setText(f"‚úÖ ƒê√£ x√≥a {len(rows_to_delete)} t√†i kho·∫£n b·ªã c·∫•m")


if __name__ == "__main__":
	app = QApplication(sys.argv)
	window = MainWindow()
	window.show()
	sys.exit(app.exec())
