from qtpy.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QGraphicsDropShadowEffect, QHeaderView, QCheckBox, QLabel, QPushButton, QAbstractItemView,
    QHBoxLayout, QFrame, QMenu, QMessageBox
)
from qtpy.QtGui import QColor, QFont, QCursor, QAction, QIcon
from qtpy.QtCore import Qt, QPropertyAnimation, QRect, QTimer, QPoint, QRunnable, QThreadPool, Signal, QObject
import sys
import os
import requests
import hashlib
import threading

FILE_PATH = "ACC.txt"

class AnimatedToggle(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(60, 30)
        self.checkbox = QCheckBox(self)
        self.checkbox.setGeometry(0, 0, 60, 30)
        self.checkbox.setCursor(Qt.PointingHandCursor)
        self.checkbox.setStyleSheet("""
            QCheckBox::indicator {
                width: 60px;
                height: 30px;
                border-radius: 15px;
                background-color: #ddd;
            }
            QCheckBox::indicator:checked {
                background-color: #6666ff;
            }
        """)
        self.icon = QLabel("\ud83c\udf1e", self)
        self.icon.setGeometry(3, 3, 24, 24)
        self.icon.setFont(QFont("Arial", 16))
        self.icon.setAlignment(Qt.AlignCenter)
        self.icon.setStyleSheet("background: transparent;")
        self.anim = QPropertyAnimation(self.icon, b"geometry")
        self.checkbox.stateChanged.connect(self.start_animation)

    def start_animation(self, state):
        if state:
            self.anim.setStartValue(QRect(3, 3, 24, 24))
            self.anim.setEndValue(QRect(33, 3, 24, 24))
            self.icon.setText("\ud83c\udf19")
        else:
            self.anim.setStartValue(QRect(33, 3, 24, 24))
            self.anim.setEndValue(QRect(3, 3, 24, 24))
            self.icon.setText("\ud83c\udf1e")
        self.anim.setDuration(200)
        self.anim.start()

    def isChecked(self):
        return self.checkbox.isChecked()

    def stateChanged(self, func):
        self.checkbox.stateChanged.connect(func)

class LoginSignals(QObject):
    update_status = Signal(int, str)  # row, status
    login_result = Signal(int, str, str, object)  # row, token, result, diem

class LoginWorker(QRunnable):
    def __init__(self, row, account, password, f_id, proxy_string, token=None):
        super().__init__()
        self.row = row
        self.account = account
        self.password = password
        self.f_id = f_id
        self.proxy_string = proxy_string
        self.token = token
        self.signals = LoginSignals()

    def create_proxy(self, proxy_string):
        parts = proxy_string.split(":")
        ip = parts[0]
        port = parts[1]
        username = parts[2]
        password = parts[3]
        proxies = {
            "http": f"http://{username}:{password}@{ip}:{port}",
            "https": f"http://{username}:{password}@{ip}:{port}"
        }
        return proxies

    def check_token_live(self, token, f_id, proxy_string):
        import requests
        proxies = self.create_proxy(proxy_string)
        try:
            headers = {
                "authority": "m.oklavip26.live",
                "accept": "application/json, text/plain, */*",
                "accept-language": "vi-VN,vi;q=0.9",
                "content-type": "application/json",
                "locale": "vi_vn",
                "referer": "https://m.oklavip26.live/personal",
                "sec-ch-ua-platform": "Windows",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                "f-id": f_id,
                "token": token,
            }
            responsediem = requests.get("https://m.oklavip26.live/api/wallet/getWallet", headers=headers, proxies=proxies, timeout=20).json()
            print(responsediem)
            diem = responsediem['data']['integral']
            return False, diem  # False = token còn sống
        except Exception as e:
            print(f"CheckTokenLive Exception: {e}")
            return True, None  # True = token die

    def run(self):
        import requests, hashlib
        from qtpy.QtWidgets import QTableWidgetItem
        # Kiểm tra token trước khi đăng nhập
        if self.token and self.token.strip():
            self.signals.update_status.emit(self.row, "Đang kiểm tra token...")
            is_die, diem = self.check_token_live(self.token, self.f_id, self.proxy_string)
            if not is_die:
                self.signals.update_status.emit(self.row, f"Token sống | Điểm: {diem}")
                # Cập nhật điểm vào cột 5
                self.signals.login_result.emit(self.row, self.token, "TOKEN_OK", diem)
                return
            else:
                self.signals.update_status.emit(self.row, "Token die, đăng nhập lại...")
        # Nếu token die hoặc không có, tiến hành đăng nhập như cũ
        def create_proxy(proxy_string):
            parts = proxy_string.split(":")
            ip = parts[0]
            port = parts[1]
            username = parts[2]
            password = parts[3]
            proxies = {
                "http": f"http://{username}:{password}@{ip}:{port}",
                "https": f"http://{username}:{password}@{ip}:{port}"
            }
            return proxies
        proxies = create_proxy(self.proxy_string)
        url = "https://oklavip26.live/api/accountLogin/captcha"
        headers_captcha = {
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, deflate, br, zstd",
            "accept-language": "vi-VN,vi;q=0.9",
            "referer": "https://oklavip26.live/?backRoute=%2Fpersonal",
            "sec-ch-ua": '"Chromium";v="136", "Google Chrome";v="136", "Not.A/Brand";v="99"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-origin",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
        }
        attempts = 0
        while attempts < 3:
            try:
                self.signals.update_status.emit(self.row, f"Lấy captcha (lần {attempts+1})...")
                response = requests.get(url, headers=headers_captcha, proxies=proxies)
                print(response.status_code)
                print(response.json())
                img = response.json()
                img_src, uuid = img['data']['image'], img['data']['uuid']
                self.signals.update_status.emit(self.row, "Đang nhận diện captcha...")
                ocr_response = requests.post("http://103.77.242.210:8000/ocr", headers={"accept": "application/json"}, data={"image": img_src}, verify=False).json()
                code = ocr_response['data']
                password_md5 = hashlib.md5(self.password.encode('utf-8')).hexdigest()
                headers_login = {
                    "authority": "m.oklavip26.live",
                    "accept": "application/json, text/plain, */*",
                    "accept-language": "vi-VN,vi;q=0.9",
                    "content-type": "application/json",
                    "locale": "vi_vn",
                    "origin": "https://m.oklavip26.live",
                    "priority": "u=1, i",
                    "referer": "https://m.oklavip26.live/login",
                    "sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
                    "sec-ch-ua-mobile": "?0",
                    "sec-ch-ua-platform": "Windows",
                    "sec-fetch-dest": "empty",
                    "sec-fetch-mode": "cors",
                    "sec-fetch-site": "same-origin",
                    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                    "f-id": self.f_id
                }
                data = {
                    "account": self.account,
                    "password": password_md5,
                    "code": code,
                    "uuid": uuid,
                    "device": "H5"
                }
                self.signals.update_status.emit(self.row, "Đang gửi thông tin đăng nhập...")
                response = requests.post(
                    "https://m.oklavip26.live/api/accountLogin/doLogin",
                    headers=headers_login,
                    json=data,
                    proxies=proxies,
                    timeout=20,
                )
                print(response.json())
                resp_json = response.json()
                if resp_json['code'] == 200:
                    print("Login successful!")
                    print(f"Token: {resp_json['data']['token']}")
                    self.signals.update_status.emit(self.row, "Đăng nhập thành công!")
                    self.signals.login_result.emit(self.row, resp_json['data']['token'], "DONE", None)
                    return
                elif resp_json['code'] == 40000:
                    print("Invalid captcha code, try again.")
                    self.signals.update_status.emit(self.row, f"Sai captcha, thử lại ({attempts+1})...")
                    attempts += 1
                else:
                    print(f"Error: {resp_json.get('message', 'Không rõ')}")
                    self.signals.update_status.emit(self.row, f"Lỗi: {resp_json.get('message', 'Không rõ')}")
                    break
            except Exception as e:
                print(f"Exception: {e}")
                attempts += 1
                self.signals.update_status.emit(self.row, f"Lỗi: {str(e)} (thử lại {attempts})")
        print("Failed to login after 3 attempts.")
        self.signals.update_status.emit(self.row, "Đăng nhập thất bại!")
        try:
            self.signals.login_result.emit(self.row, "", "FAILED", None)
        except Exception as e:
            print(f"Emit failed: {e}")

class Table3D(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Bảng 3D - ACC Loader")
        self.resize(1200, 600)
        self.is_dark = False
        self.password_map = {}
        self.password_shown = set()
        self.threadpool = QThreadPool()
        self.threadpool.setMaxThreadCount(200)
        self.is_login_all = False
        self.init_ui()

    def toggle_theme(self, state):
        self.is_dark = bool(state)
        if self.is_dark:
            self.apply_dark_theme()
        else:
            self.apply_light_theme()

    def apply_light_theme(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                color: #000;
            }
            QTableWidget {
                background-color: #ffffff;
                alternate-background-color: #f9f9f9;
            }
            QLabel {
                color: #333;
            }
        """)

    def apply_dark_theme(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                color: #fff;
            }
            QTableWidget {
                background-color: #3c3f41;
                alternate-background-color: #313335;
            }
            QLabel {
                color: #fff;
            }
        """)

    def init_ui(self):
        layout = QVBoxLayout(self)
        top_bar = QHBoxLayout()

        self.toggle = AnimatedToggle()
        self.toggle.stateChanged(self.toggle_theme)

        self.total_label = QLabel("Tổng điểm: 0 | Tổng ACC: 0")
        self.total_label.setFont(QFont("Arial", 12))
        self.total_label.setStyleSheet("color: #333;")

        self.login_all_btn = QPushButton("Đăng nhập tất cả")
        self.login_all_btn.clicked.connect(self.login_all_accounts)
        self.login_all_btn.setStyleSheet('''
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4f8cff, stop:1 #2353ff);
                color: white;
                border-radius: 15px;
                padding: 8px 24px;
                font-size: 15px;
                font-weight: bold;
                border: none;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #6faaff, stop:1 #3a6cff);
                color: #fff;
            }
            QPushButton:pressed {
                background: #2353ff;
            }
        ''')

        self.run_all_btn = QPushButton("Làm Nhiệm Vụ Tất Cả")
        self.run_all_btn.clicked.connect(self.run_all_tasks)
        self.run_all_btn.setStyleSheet(self.login_all_btn.styleSheet())

        self.check_proxy_btn = QPushButton("Kiểm Tra Proxy")
        self.check_proxy_btn.clicked.connect(self.check_proxy_all)
        self.check_proxy_btn.setStyleSheet(self.login_all_btn.styleSheet())

        self.replace_proxy_btn = QPushButton("Thay Proxy Không Hoạt Động")
        self.replace_proxy_btn.clicked.connect(self.replace_dead_proxies)
        self.replace_proxy_btn.setStyleSheet(self.login_all_btn.styleSheet())

        self.get_point_all_btn = QPushButton("Lấy điểm tất cả")
        self.get_point_all_btn.clicked.connect(self.get_point_all)
        self.get_point_all_btn.setStyleSheet(self.login_all_btn.styleSheet())

        top_bar.addWidget(self.toggle)
        top_bar.addWidget(self.login_all_btn)
        top_bar.addWidget(self.run_all_btn)
        top_bar.addWidget(self.check_proxy_btn)
        top_bar.addWidget(self.replace_proxy_btn)
        top_bar.addWidget(self.get_point_all_btn)
        top_bar.addStretch()
        top_bar.addWidget(self.total_label)

        self.table = QTableWidget()
        self.table.setColumnCount(8)
        self.table.setHorizontalHeaderLabels([
            "Token", "Proxy", "Tài khoản", "Mật khẩu", "F-ID",
            "Điểm", "Trạng thái", "Ghi chú"
        ])
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setAlternatingRowColors(True)
        self.table.setStyleSheet("QTableWidget::item:selected { background-color: #ADD8E6; }")

        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(10)
        shadow.setColor(QColor(0, 0, 0, 160))
        shadow.setOffset(3, 3)
        self.table.setGraphicsEffect(shadow)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)

        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.table.setColumnWidth(0, 50)   # Token
        self.table.setColumnWidth(1, 50)   # Proxy
        self.table.setColumnWidth(2, 120)  # Tài khoản
        self.table.setColumnWidth(3, 70)  # Mật khẩu
        self.table.setColumnWidth(4, 80)   # F-ID
        self.table.setColumnWidth(5, 80)   # Điểm
        self.table.setColumnWidth(6, 470)  # Trạng thái (to nhất)
        self.table.setColumnWidth(7, 250)  # Ghi chú (bình thường)

        layout.addLayout(top_bar)
        layout.addWidget(self.table)

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_totals)
        self.timer.start(1000)

        self.load_data()
        self.apply_light_theme()

    def show_context_menu(self, pos):
        menu = QMenu()
        login_action = menu.addAction("Đăng Nhập")
        get_point_action = menu.addAction("Lấy điểm")
        run_action = menu.addAction("Làm Nhiệm Vụ")
        # withdraw_action = menu.addAction("Rút Điểm")
        action = menu.exec_(self.table.mapToGlobal(pos))
        if action == login_action:
            self.login_selected_account()
        elif action == get_point_action:
            self.get_point_selected()
        elif action == run_action:
            self.run_selected_task()

    def login_selected_account(self):
        row = self.table.currentRow()
        if row == -1:
            return
        self.is_login_all = False
        account = self.table.item(row, 2).text()
        password = self.password_map.get(row)
        f_id = self.table.item(row, 4).text()
        proxy_string = self.table.item(row, 1).text()
        token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        worker = LoginWorker(row, account, password, f_id, proxy_string, token)
        worker.signals.update_status.connect(self.update_status)
        worker.signals.login_result.connect(self.handle_login_result)
        self.threadpool.start(worker)

    def login_all_accounts(self):
        self.is_login_all = True
        for row in range(self.table.rowCount()):
            account = self.table.item(row, 2).text()
            password = self.password_map.get(row)
            f_id = self.table.item(row, 4).text()
            proxy_string = self.table.item(row, 1).text()
            token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
            worker = LoginWorker(row, account, password, f_id, proxy_string, token)
            worker.signals.update_status.connect(self.update_status)
            worker.signals.login_result.connect(self.handle_login_result)
            self.threadpool.start(worker)

    def update_status(self, row, status):
        self.table.setItem(row, 6, QTableWidgetItem(status))
        print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: {status}")

    def handle_login_result(self, row, token, result, diem):
        if result == "DONE":
            self.table.setItem(row, 0, QTableWidgetItem(token))
            print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: Đăng nhập thành công!")
            # Cập nhật toàn bộ dòng vào file ACC.txt
            try:
                acc_file = FILE_PATH
                with open(acc_file, "r", encoding="utf-8") as f:
                    lines = f.readlines()
                if 0 <= row < len(lines):
                    # Lấy lại toàn bộ dữ liệu dòng từ bảng
                    new_cells = []
                    for col in range(self.table.columnCount()):
                        item = self.table.item(row, col)
                        new_cells.append(item.text() if item else "")
                    # Đảm bảo có 8 trường
                    if len(new_cells) < 8:
                        new_cells += [""] * (8 - len(new_cells))
                    lines[row] = "|".join(new_cells) + "\n"
                    with open(acc_file, "w", encoding="utf-8") as f:
                        f.writelines(lines)
                    print(f"[LOG] Đã cập nhật toàn bộ dòng vào file ACC.txt cho dòng {row}")
            except Exception as e:
                print(f"[LOG] Lỗi cập nhật dòng vào file ACC.txt: {e}")
            if not self.is_login_all:
                QMessageBox.information(self, "Đăng nhập", f"Đăng nhập thành công cho tài khoản {self.table.item(row,2).text()}.")
        elif result == "TOKEN_OK":
            # Token còn sống, chỉ update điểm
            if diem is not None:
                self.table.setItem(row, 5, QTableWidgetItem(str(diem)))
                print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: Token sống, điểm: {diem}")
        elif result == "GET_POINT_OK":
            if diem is not None:
                self.table.setItem(row, 5, QTableWidgetItem(str(diem)))
                print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: Lấy điểm thành công: {diem}")
                # Lưu lại dòng vào file ACC.txt
                try:
                    acc_file = FILE_PATH
                    with open(acc_file, "r", encoding="utf-8") as f:
                        lines = f.readlines()
                    if 0 <= row < len(lines):
                        new_cells = []
                        for col in range(self.table.columnCount()):
                            item = self.table.item(row, col)
                            new_cells.append(item.text() if item else "")
                        if len(new_cells) < 8:
                            new_cells += [""] * (8 - len(new_cells))
                        lines[row] = "|".join(new_cells) + "\n"
                        with open(acc_file, "w", encoding="utf-8") as f:
                            f.writelines(lines)
                        print(f"[LOG] Đã lưu dòng vào file ACC.txt sau khi lấy điểm cho dòng {row}")
                except Exception as e:
                    print(f"[LOG] Lỗi lưu dòng vào file ACC.txt sau khi lấy điểm: {e}")
        elif result == "GET_POINT_FAIL":
            print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: Lấy điểm thất bại!")
        else:
            print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: Đăng nhập thất bại!")
            if not self.is_login_all:
                QMessageBox.critical(self, "Đăng nhập thất bại", f"Không thể đăng nhập tài khoản {self.table.item(row,2).text()}.")

    def update_totals(self):
        total_diem = 0
        for row in range(self.table.rowCount()):
            try:
                total_diem += int(self.table.item(row, 5).text())
            except:
                continue
        self.total_label.setText(f"Tổng điểm: {total_diem} | Tổng ACC: {self.table.rowCount()}")

    def load_data(self):
        if not os.path.exists(FILE_PATH): return
        with open(FILE_PATH, "r", encoding="utf-8") as f:
            lines = f.readlines()
        self.table.setRowCount(len(lines))
        for row, line in enumerate(lines):
            cells = line.strip().split("|")
            while len(cells) < 8:
                cells.append("")
            for col, text in enumerate(cells):
                item = QTableWidgetItem(text)
                item.setTextAlignment(Qt.AlignCenter)
                self.table.setItem(row, col, item)
            self.password_map[row] = cells[3]

    def get_point_selected(self):
        row = self.table.currentRow()
        if row == -1:
            return
        token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        f_id = self.table.item(row, 4).text()
        proxy_string = self.table.item(row, 1).text()
        worker = GetPointWorker(row, token, f_id, proxy_string)
        worker.signals.update_status.connect(self.update_status)
        worker.signals.login_result.connect(self.handle_login_result)
        self.threadpool.start(worker)

    def get_point_all(self):
        for row in range(self.table.rowCount()):
            token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
            f_id = self.table.item(row, 4).text()
            proxy_string = self.table.item(row, 1).text()
            worker = GetPointWorker(row, token, f_id, proxy_string)
            worker.signals.update_status.connect(self.update_status)
            worker.signals.login_result.connect(self.handle_login_result)
            self.threadpool.start(worker)

    def run_selected_task(self):
        row = self.table.currentRow()
        if row == -1:
            return
        threading.Thread(target=self.ChAyAll, args=(row,), daemon=True).start()

    def ChAyAll(self, row):
        try:
            import time
            self.table.setItem(row, 6, QTableWidgetItem(f"Bắt Đầu"))
            self.table.setItem(row, 6, QTableWidgetItem(f"Check Token"))
            chechDangNhap = self.CheckLoginssssss(row)
            print(chechDangNhap)
            if chechDangNhap:
                self.table.setItem(row, 6, QTableWidgetItem(f"Bắt Trả Lời Câu Hỏi"))
                self.CheckLuotTraLoiall(row)
                self.table.setItem(row, 6, QTableWidgetItem(f"Bắt Quay Chữ"))
                self.CheckGhepChuall(row)
                self.table.setItem(row, 6, QTableWidgetItem(f"☑️☑️☑️☑️☑️☑️☑️☑️☑️☑️"))
            else:
                self.table.setItem(row, 6, QTableWidgetItem(f"[💩💩💩]> Token Chết MẸ Rồi em!"))
        except Exception as e:
            self.table.setItem(row, 6, QTableWidgetItem(f"[💩💩💩]> Lỗi Cái Chó Gì Á Tự Check !"))

    def CheckLoginssssss(self, row):
        # Dummy check: token phải khác rỗng và không phải 'die' (bạn thay bằng API check thật nếu có)
        token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        return bool(token and token.lower() != 'die')

    def CheckLuotTraLoiall(self, selected_row):
        import random, time, requests
        def lay_answer_list():
            if not hasattr(lay_answer_list, "shuffled_answers") or lay_answer_list.index >= len(lay_answer_list.shuffled_answers):
                all_answers = [
                    {"id":"1813068590722039810","submitAnswer":"B"},
                    {"id":"1885293145245704194","submitAnswer":"D"},
                    {"id":"1813055126444163073","submitAnswer":"B"},
                    {"id":"1758663639615070209","submitAnswer":"D"},
                    {"id":"1785300906974543873","submitAnswer":"B"},
                    {"id":"1832001421560930305","submitAnswer":"C"},
                    {"id":"1862969516842795009","submitAnswer":"A"},
                    {"id":"1813061385461415937","submitAnswer":"C"},
                    {"id":"1852195947499892738","submitAnswer":"C"},
                    {"id":"1845597110031245313","submitAnswer":"A"},
                    {"id":"1852198018005479426","submitAnswer":"B"},
                    {"id":"1785310696345862145","submitAnswer":"B"},
                    {"id":"1785286596449697793","submitAnswer":"D"},
                    {"id":"1742430977931452417","submitAnswer":"D"},
                    {"id":"1839964599813079042","submitAnswer":"D"},
                    {"id":"1854143870443585537","submitAnswer":"D"},
                    {"id":"1785518438150995969","submitAnswer":"B"},
                    {"id":"1824048832353558530","submitAnswer":"C"},
                    {"id":"1832922633518604290","submitAnswer":"A"},
                    {"id":"1845605186754994177","submitAnswer":"A"},
                    {"id":"1910234836605042689","submitAnswer":"C"},
                    {"id":"1743642787544043521","submitAnswer":"C"},
                    {"id":"1839623537886142465","submitAnswer":"B"},
                    {"id":"1857079383320297474","submitAnswer":"B"},
                    {"id":"1758729048947089409","submitAnswer":"D"},
                    {"id":"1913734370549690370","submitAnswer":"A"},
                    {"id":"1790399254207328258","submitAnswer":"A"},
                    {"id":"1758658110029225986","submitAnswer":"B"},
                    {"id":"1857079675314675714","submitAnswer":"C"},
                    {"id":"1906204991478239234","submitAnswer":"B"},
                    {"id":"1813068590722039810","submitAnswer":"B"},
                    {"id":"1758661648285360129","submitAnswer":"C"},
                    {"id":"1900874100297801729","submitAnswer":"A"},
                    {"id":"1785309013456879617","submitAnswer":"A"}
                ]
                random.shuffle(all_answers)
                lay_answer_list.shuffled_answers = all_answers
                lay_answer_list.index = 0
            start = lay_answer_list.index
            end = start + 5
            result = lay_answer_list.shuffled_answers[start:end]
            lay_answer_list.index += 5
            return result
        token = self.table.item(selected_row, 0).text()
        proxy = self.table.item(selected_row, 1).text()
        f_id = self.table.item(selected_row, 4).text()
        self.table.setItem(selected_row, 6, QTableWidgetItem("Bắt đầu kiểm tra"))
        try:
            proxy_url, port, username, password = proxy.split(':')
            proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
            proxies = {"http": proxy_address, "https": proxy_address}
            headers = {
                "authority": "m.oklavip26.live",
                "accept": "application/json, text/plain, */*",
                "accept-language": "vi-VN,vi;q=0.9",
                "content-type": "application/json",
                "locale": "vi_vn",
                "origin": "https://m.oklavip26.live",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": "Windows",
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                "f-id": f_id,
                "token": token,
                "cache-control": "no-cache",
                "pragma": "no-cache",
                "referer": "https://m.oklavip26.live/",
            }
            response = requests.get(
                "https://m.oklavip26.live/api/activityQuestion/getActivityQuestionInfo",
                headers=headers, proxies=proxies, timeout=500).json()
            luot = response['data']['surplusNumber']
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Còn {luot} lượt"))
            for cac in range(int(luot)):
                DanhSachCauHoi = requests.get('https://m.oklavip26.live/api/activityQuestion/getQuestionList',headers=headers, proxies=proxies, timeout=500).json()['data']
                delay_time = random.randint(20, 35)
                for delay in range(delay_time, -1, -1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay}"))
                    time.sleep(1)
                date_time = int(time.time())
                recordNo = requests.get('https://m.oklavip26.live/api/activityQuestion/startAnswerQuestion',headers=headers, proxies=proxies, timeout=500).json()['data']['recordNo']
                dataTraloi = {
                    "answerList": lay_answer_list(),
                    "timeStart": date_time,
                    "recordNo": recordNo
                }
                response = requests.post('https://m.oklavip26.live/api/activityQuestion/submitQuestion',headers=headers,json=dataTraloi, proxies=proxies, timeout=500)
                print(response.json())
                time.sleep(3)
            CheckLuotQuay=requests.get("https://m.oklavip26.live/api/lottery/getLuckyDrawBaseInfo",headers=headers , proxies=proxies , timeout=500).json()
            data2 = {"raffleId": CheckLuotQuay['data']['raffleId']}
            CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/getLuckyDrawInfoByDaily",headers=headers , proxies=proxies , timeout=500).json()['data']['drawCount']
            for xx in range(int(CheckLuotQuay)):
                CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/lotteryByDaily",headers=headers, json=data2 , proxies=proxies , timeout=500).json()
                delay_time = random.randint(5,6)
                for delay in range(delay_time, -1, -1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{CheckLuotQuay}]") )
                    time.sleep(1)
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Xong!"))
        except Exception as e:
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Lỗi kiểm tra lượt: {str(e)}"))

    def CheckGhepChuall(self, selected_row):
        import requests, time
        row = selected_row
        token = self.table.item(row, 0).text()
        proxy = self.table.item(row, 1).text()
        f_id = self.table.item(row, 4).text()
        proxy_url, port, username, password = proxy.split(':')
        proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
        proxies = {
            "http": proxy_address,
            "https": proxy_address
        }
        headers = {
            "authority": "m.oklavip26.live",
            "accept": "application/json, text/plain, */*",
            "accept-language": "vi-VN,vi;q=0.9",
            "content-type": "application/json",
            "locale": "vi_vn",
            "origin": "https://m.oklavip26.live",
            "priority": "u=1, i",
            "sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "Windows",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-origin",
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
            "f-id": f_id,
            "token": token,
            "cache-control": "no-cache",
            "pragma": "no-cache",
            "referer": "https://m.oklavip26.live/",
        }
        try:
            response = requests.get('https://m.oklavip26.live/api/activityCollect/getListAvailable', headers=headers, proxies=proxies, timeout=500).json()
            idGame = response['data'][0]['id']
            data = {"id": idGame}
            draw_response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500).json()
            draw_times = draw_response['data']['drawTimes']
            status_text = f"Lượt ghép chữ còn lại: {draw_times}"
            self.table.setItem(selected_row, 6, QTableWidgetItem(status_text))
            for _ in range(int(draw_times)):
                response = requests.post('https://m.oklavip26.live/api/activityCollect/drawWord', headers=headers, json=data, proxies=proxies, timeout=500)
                for delay in range(5,-1,-1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response.json()['data']['textName']}]") )
                    time.sleep(1)
            response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500)
            synthesisTimes = response.json()['data']['synthesisTimes']
            data2 = {"raffleId": requests.get("https://m.oklavip26.live/api/activityCollect/getListAvailable", headers=headers, proxies=proxies, timeout=500).json()['data'][0]['lotteryId']}
            for _ in range(int(synthesisTimes)):
                response = requests.post('https://m.oklavip26.live/api/activityCollect/mergeWord', headers=headers, json=data, proxies=proxies, timeout=500)
                response2 = requests.post('https://m.oklavip26.live/api/lottery/lottery', headers=headers, json=data2, proxies=proxies, timeout=500)
                for delay in range(5,-1,-1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response2.json()['data']['prizeInfo']['prizeName']}]") )
                    time.sleep(1)
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Ghép Chữ Hoàn Tất!"))
        except Exception as e:
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Lỗi ghép chữ: {str(e)}"))

    def run_all_tasks(self):
        import threading
        for row in range(self.table.rowCount()):
            threading.Thread(target=self.ChAyAll, args=(row,), daemon=True).start()

    def check_proxy_all(self):
        threading.Thread(target=self._check_proxy_thread, daemon=True).start()

    def _check_proxy_thread(self):
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import requests
        from qtpy.QtWidgets import QTableWidgetItem, QDialog, QVBoxLayout, QTextEdit, QLabel, QPushButton
        import time
        proxy_errors = []
        lock = threading.Lock()
        def xu_ly_row(row):
            proxy = self.table.item(row, 1).text()
            self.table.setItem(row, 6, QTableWidgetItem(f"[XXX] Kiểm Tra Mạng Máy!"))
            def kiem_tra_mang():
                for lan in range(3):
                    try:
                        requests.get("https://www.google.com", timeout=10)
                        return True
                    except requests.RequestException:
                        self.table.setItem(row, 6, QTableWidgetItem(f"❌ Máy tính không có kết nối mạng. Thử lại lần {lan + 1}"))
                return False
            def kiem_tra_proxy(proxy_str):
                try:
                    ip, port, user, password = proxy_str.split(":")
                    proxy_url = f"http://{user}:{password}@{ip}:{port}"
                    proxies = {"http": proxy_url, "https": proxy_url}
                    response = requests.get("https://geo.myip.link/", proxies=proxies, timeout=10)
                    if response.status_code == 200:
                        return True, response.json()
                    else:
                        return False, f"Lỗi mã trạng thái HTTP: {response.status_code}"
                except Exception as e:
                    return False, str(e)
            if kiem_tra_mang():
                self.table.setItem(row, 6, QTableWidgetItem(f"✅ Mạng hoạt động."))
                thanh_cong, ket_qua = kiem_tra_proxy(proxy)
                if thanh_cong:
                    self.table.setItem(row, 6, QTableWidgetItem(f"✅ Proxy hoạt động. "))
                else:
                    self.table.setItem(row, 6, QTableWidgetItem(f"❌ Proxy không hoạt động. "))
                    with lock:
                        proxy_errors.append((row, proxy, ket_qua))
                    # Lưu lại dòng lỗi vào ACC.txt
                    try:
                        acc_file = FILE_PATH
                        with open(acc_file, "r", encoding="utf-8") as f:
                            lines = f.readlines()
                        if 0 <= row < len(lines):
                            new_cells = []
                            for col in range(self.table.columnCount()):
                                item = self.table.item(row, col)
                                new_cells.append(item.text() if item else "")
                            if len(new_cells) < 8:
                                new_cells += [""] * (8 - len(new_cells))
                            lines[row] = "|".join(new_cells) + "\n"
                            with open(acc_file, "w", encoding="utf-8") as f:
                                f.writelines(lines)
                    except Exception as e:
                        print(f"[LOG] Lỗi lưu dòng proxy lỗi vào file ACC.txt: {e}")
            else:
                self.table.setItem(row, 6, QTableWidgetItem(f"❌ Máy tính không có kết nối mạng."))
        with ThreadPoolExecutor(max_workers=30) as executor:
            futures = [executor.submit(xu_ly_row, row) for row in range(self.table.rowCount())]
            for future in as_completed(futures):
                pass
        # Hiện popup báo proxy lỗi
        if proxy_errors:
            def show_error_dialog():
                dialog = QDialog(self)
                dialog.setWindowTitle("Danh sách proxy lỗi")
                layout = QVBoxLayout(dialog)
                label = QLabel(f"Tổng số proxy lỗi: {len(proxy_errors)}")
                layout.addWidget(label)
                textedit = QTextEdit()
                textedit.setReadOnly(True)
                textedit.setMinimumWidth(400)
                textedit.setMinimumHeight(200)
                textedit.setText("\n".join([f"{row+1}: {proxy} - {err}" for row, proxy, err in proxy_errors]))
                layout.addWidget(textedit)
                btn = QPushButton("Đóng")
                btn.clicked.connect(dialog.accept)
                layout.addWidget(btn)
                # CSS đẹp cho dialog
                dialog.setStyleSheet('''
                    QDialog {
                        background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #4f8cff, stop:1 #8f5cff);
                        border-radius: 18px;
                    }
                    QLabel {
                        color: white;
                        font-size: 18px;
                        font-weight: bold;
                        padding: 16px 8px 8px 8px;
                    }
                    QPushButton {
                        background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #6faaff, stop:1 #3a6cff);
                        color: white;
                        border-radius: 12px;
                        padding: 8px 24px;
                        font-size: 15px;
                        font-weight: bold;
                        border: none;
                        margin-bottom: 12px;
                    }
                    QPushButton:hover {
                        background: #2353ff;
                    }
                ''')
                dialog.exec_()
            QTimer.singleShot(0, lambda: show_error_dialog())
            # Lưu lại proxy lỗi cho chức năng thay proxy
            self._last_proxy_errors = proxy_errors
        else:
            self._last_proxy_errors = []

    def replace_dead_proxies(self):
        # Tìm lại proxy lỗi từ lần kiểm tra gần nhất
        if not hasattr(self, '_last_proxy_errors') or not self._last_proxy_errors:
            QMessageBox.information(self, "Thông báo", "Bạn cần kiểm tra proxy trước khi thay proxy lỗi!")
            return
        from qtpy.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QLabel, QPushButton
        proxy_errors = self._last_proxy_errors
        dialog = QDialog(self)
        dialog.setWindowTitle("Thay Proxy Không Hoạt Động")
        layout = QVBoxLayout(dialog)
        label = QLabel(f"Nhập {len(proxy_errors)} proxy mới, mỗi proxy 1 dòng, đúng thứ tự:")
        layout.addWidget(label)
        textedit = QTextEdit()
        textedit.setMinimumWidth(400)
        textedit.setMinimumHeight(200)
        layout.addWidget(textedit)
        btn = QPushButton("Thay thế")
        layout.addWidget(btn)
        def on_replace():
            new_proxies = [line.strip() for line in textedit.toPlainText().splitlines() if line.strip()]
            if len(new_proxies) != len(proxy_errors):
                QMessageBox.warning(dialog, "Lỗi", f"Bạn phải nhập đúng {len(proxy_errors)} proxy!")
                return
            # Thay vào bảng và file ACC.txt
            acc_file = FILE_PATH
            with open(acc_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
            for idx, (row, old_proxy, err) in enumerate(proxy_errors):
                proxy = new_proxies[idx]
                # Update bảng
                self.table.setItem(row, 1, QTableWidgetItem(proxy))
                # Update file
                if 0 <= row < len(lines):
                    cells = lines[row].strip().split("|")
                    if len(cells) < 8:
                        cells += [""] * (8 - len(cells))
                    cells[1] = proxy
                    lines[row] = "|".join(cells) + "\n"
            with open(acc_file, "w", encoding="utf-8") as f:
                f.writelines(lines)
            QMessageBox.information(dialog, "Thành công", "Đã thay proxy mới cho các dòng lỗi!")
            dialog.accept()
        btn.clicked.connect(on_replace)
        dialog.exec_()

class GetPointWorker(QRunnable):
    def __init__(self, row, token, f_id, proxy_string):
        super().__init__()
        self.row = row
        self.token = token
        self.f_id = f_id
        self.proxy_string = proxy_string
        self.signals = LoginSignals()

    def create_proxy(self, proxy_string):
        parts = proxy_string.split(":")
        ip = parts[0]
        port = parts[1]
        username = parts[2]
        password = parts[3]
        proxies = {
            "http": f"http://{username}:{password}@{ip}:{port}",
            "https": f"http://{username}:{password}@{ip}:{port}"
        }
        return proxies

    def run(self):
        import requests
        proxies = self.create_proxy(self.proxy_string)
        try:
            headers = {
                "authority": "m.oklavip26.live",
                "accept": "application/json, text/plain, */*",
                "accept-language": "vi-VN,vi;q=0.9",
                "content-type": "application/json",
                "locale": "vi_vn",
                "referer": "https://m.oklavip26.live/personal",
                "sec-ch-ua-platform": "Windows",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                "f-id": self.f_id,
                "token": self.token,
            }
            responsediem = requests.get("https://m.oklavip26.live/api/wallet/getWallet", headers=headers, proxies=proxies, timeout=20).json()
            print(responsediem)
            diem = responsediem['data']['integral']
            self.signals.update_status.emit(self.row, f"Lấy điểm thành công: {diem}")
            self.signals.login_result.emit(self.row, self.token, "GET_POINT_OK", diem)
        except Exception as e:
            print(f"GetPointWorker Exception: {e}")
            self.signals.update_status.emit(self.row, "Lấy điểm thất bại!")
            self.signals.login_result.emit(self.row, self.token, "GET_POINT_FAIL", None)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    from qtpy.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton
    def show_notice():
        dialog = QDialog()
        dialog.setWindowTitle("Thông báo")
        layout = QVBoxLayout(dialog)
        label = QLabel("Tool đang trong quá trình hoàn thiện sẽ đầy đủ chức năng")
        label.setWordWrap(True)
        layout.addWidget(label)
        btn = QPushButton("Đóng")
        btn.clicked.connect(dialog.accept)
        layout.addWidget(btn)
        # CSS đẹp cho dialog
        dialog.setStyleSheet('''
            QDialog {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #4f8cff, stop:1 #8f5cff);
                border-radius: 18px;
            }
            QLabel {
                color: white;
                font-size: 18px;
                font-weight: bold;
                padding: 16px 8px 8px 8px;
            }
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #6faaff, stop:1 #3a6cff);
                color: white;
                border-radius: 12px;
                padding: 8px 24px;
                font-size: 15px;
                font-weight: bold;
                border: none;
                margin-bottom: 12px;
            }
            QPushButton:hover {
                background: #2353ff;
            }
        ''')
        dialog.exec_()
    QTimer.singleShot(0, show_notice)
    win = Table3D()
    win.show()
    sys.exit(app.exec())
