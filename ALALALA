from qtpy.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QGraphicsDropShadowEffect, QHeaderView, QCheckBox, QLabel, QPushButton, QAbstractItemView,
    QHBoxLayout, QFrame, QMenu, QMessageBox
)
from qtpy.QtGui import QColor, QFont, QCursor, QAction, QIcon
from qtpy.QtCore import Qt, QPropertyAnimation, QRect, QTimer, QPoint, QRunnable, QThreadPool, Signal, QObject
import sys
import os
import requests
import hashlib
import threading

FILE_PATH = "ACC.txt"

class AnimatedToggle(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(60, 30)
        self.checkbox = QCheckBox(self)
        self.checkbox.setGeometry(0, 0, 60, 30)
        self.checkbox.setCursor(Qt.PointingHandCursor)
        self.checkbox.setStyleSheet("""
            QCheckBox::indicator {
                width: 60px;
                height: 30px;
                border-radius: 15px;
                background-color: #ddd;
            }
            QCheckBox::indicator:checked {
                background-color: #6666ff;
            }
        """)
        self.icon = QLabel("\ud83c\udf1e", self)
        self.icon.setGeometry(3, 3, 24, 24)
        self.icon.setFont(QFont("Arial", 16))
        self.icon.setAlignment(Qt.AlignCenter)
        self.icon.setStyleSheet("background: transparent;")
        self.anim = QPropertyAnimation(self.icon, b"geometry")
        self.checkbox.stateChanged.connect(self.start_animation)

    def start_animation(self, state):
        if state:
            self.anim.setStartValue(QRect(3, 3, 24, 24))
            self.anim.setEndValue(QRect(33, 3, 24, 24))
            self.icon.setText("\ud83c\udf19")
        else:
            self.anim.setStartValue(QRect(33, 3, 24, 24))
            self.anim.setEndValue(QRect(3, 3, 24, 24))
            self.icon.setText("\ud83c\udf1e")
        self.anim.setDuration(200)
        self.anim.start()

    def isChecked(self):
        return self.checkbox.isChecked()

    def stateChanged(self, func):
        self.checkbox.stateChanged.connect(func)

class LoginSignals(QObject):
    update_status = Signal(int, str)  # row, status
    login_result = Signal(int, str, str, object)  # row, token, result, diem

class LoginWorker(QRunnable):
    def __init__(self, row, account, password, f_id, proxy_string, token=None):
        super().__init__()
        self.row = row
        self.account = account
        self.password = password
        self.f_id = f_id
        self.proxy_string = proxy_string
        self.token = token
        self.signals = LoginSignals()

    def create_proxy(self, proxy_string):
        parts = proxy_string.split(":")
        ip = parts[0]
        port = parts[1]
        username = parts[2]
        password = parts[3]
        proxies = {
            "http": f"http://{username}:{password}@{ip}:{port}",
            "https": f"http://{username}:{password}@{ip}:{port}"
        }
        return proxies

    def check_token_live(self, token, f_id, proxy_string):
        import requests
        proxies = self.create_proxy(proxy_string)
        try:
            headers = {
                "authority": "m.oklavip26.live",
                "accept": "application/json, text/plain, */*",
                "accept-language": "vi-VN,vi;q=0.9",
                "content-type": "application/json",
                "locale": "vi_vn",
                "referer": "https://m.oklavip26.live/personal",
                "sec-ch-ua-platform": "Windows",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                "f-id": f_id,
                "token": token,
            }
            responsediem = requests.get("https://m.oklavip26.live/api/wallet/getWallet", headers=headers, proxies=proxies, timeout=20).json()
            print(responsediem)
            diem = responsediem['data']['integral']
            return False, diem  # False = token c√≤n s·ªëng
        except Exception as e:
            print(f"CheckTokenLive Exception: {e}")
            return True, None  # True = token die

    def run(self):
        import requests, hashlib
        from qtpy.QtWidgets import QTableWidgetItem
        # Ki·ªÉm tra token tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p
        if self.token and self.token.strip():
            self.signals.update_status.emit(self.row, "ƒêang ki·ªÉm tra token...")
            is_die, diem = self.check_token_live(self.token, self.f_id, self.proxy_string)
            if not is_die:
                self.signals.update_status.emit(self.row, f"Token s·ªëng | ƒêi·ªÉm: {diem}")
                # C·∫≠p nh·∫≠t ƒëi·ªÉm v√†o c·ªôt 5
                self.signals.login_result.emit(self.row, self.token, "TOKEN_OK", diem)
                return
            else:
                self.signals.update_status.emit(self.row, "Token die, ƒëƒÉng nh·∫≠p l·∫°i...")
        # N·∫øu token die ho·∫∑c kh√¥ng c√≥, ti·∫øn h√†nh ƒëƒÉng nh·∫≠p nh∆∞ c≈©
        def create_proxy(proxy_string):
            parts = proxy_string.split(":")
            ip = parts[0]
            port = parts[1]
            username = parts[2]
            password = parts[3]
            proxies = {
                "http": f"http://{username}:{password}@{ip}:{port}",
                "https": f"http://{username}:{password}@{ip}:{port}"
            }
            return proxies
        proxies = create_proxy(self.proxy_string)
        url = "https://oklavip26.live/api/accountLogin/captcha"
        headers_captcha = {
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, deflate, br, zstd",
            "accept-language": "vi-VN,vi;q=0.9",
            "referer": "https://oklavip26.live/?backRoute=%2Fpersonal",
            "sec-ch-ua": '"Chromium";v="136", "Google Chrome";v="136", "Not.A/Brand";v="99"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-origin",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36"
        }
        attempts = 0
        while attempts < 3:
            try:
                self.signals.update_status.emit(self.row, f"L·∫•y captcha (l·∫ßn {attempts+1})...")
                response = requests.get(url, headers=headers_captcha, proxies=proxies)
                print(response.status_code)
                print(response.json())
                img = response.json()
                img_src, uuid = img['data']['image'], img['data']['uuid']
                self.signals.update_status.emit(self.row, "ƒêang nh·∫≠n di·ªán captcha...")
                ocr_response = requests.post("http://103.77.242.210:8000/ocr", headers={"accept": "application/json"}, data={"image": img_src}, verify=False).json()
                code = ocr_response['data']
                password_md5 = hashlib.md5(self.password.encode('utf-8')).hexdigest()
                headers_login = {
                    "authority": "m.oklavip26.live",
                    "accept": "application/json, text/plain, */*",
                    "accept-language": "vi-VN,vi;q=0.9",
                    "content-type": "application/json",
                    "locale": "vi_vn",
                    "origin": "https://m.oklavip26.live",
                    "priority": "u=1, i",
                    "referer": "https://m.oklavip26.live/login",
                    "sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
                    "sec-ch-ua-mobile": "?0",
                    "sec-ch-ua-platform": "Windows",
                    "sec-fetch-dest": "empty",
                    "sec-fetch-mode": "cors",
                    "sec-fetch-site": "same-origin",
                    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                    "f-id": self.f_id
                }
                data = {
                    "account": self.account,
                    "password": password_md5,
                    "code": code,
                    "uuid": uuid,
                    "device": "H5"
                }
                self.signals.update_status.emit(self.row, "ƒêang g·ª≠i th√¥ng tin ƒëƒÉng nh·∫≠p...")
                response = requests.post(
                    "https://m.oklavip26.live/api/accountLogin/doLogin",
                    headers=headers_login,
                    json=data,
                    proxies=proxies,
                    timeout=20,
                )
                print(response.json())
                resp_json = response.json()
                if resp_json['code'] == 200:
                    print("Login successful!")
                    print(f"Token: {resp_json['data']['token']}")
                    self.signals.update_status.emit(self.row, "ƒêƒÉng nh·∫≠p th√†nh c√¥ng!")
                    self.signals.login_result.emit(self.row, resp_json['data']['token'], "DONE", None)
                    return
                elif resp_json['code'] == 40000:
                    print("Invalid captcha code, try again.")
                    self.signals.update_status.emit(self.row, f"Sai captcha, th·ª≠ l·∫°i ({attempts+1})...")
                    attempts += 1
                else:
                    print(f"Error: {resp_json.get('message', 'Kh√¥ng r√µ')}")
                    self.signals.update_status.emit(self.row, f"L·ªói: {resp_json.get('message', 'Kh√¥ng r√µ')}")
                    break
            except Exception as e:
                print(f"Exception: {e}")
                attempts += 1
                self.signals.update_status.emit(self.row, f"L·ªói: {str(e)} (th·ª≠ l·∫°i {attempts})")
        print("Failed to login after 3 attempts.")
        self.signals.update_status.emit(self.row, "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i!")
        try:
            self.signals.login_result.emit(self.row, "", "FAILED", None)
        except Exception as e:
            print(f"Emit failed: {e}")

class Table3D(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("B·∫£ng 3D - ACC Loader")
        self.resize(1200, 600)
        self.is_dark = False
        self.password_map = {}
        self.password_shown = set()
        self.threadpool = QThreadPool()
        self.threadpool.setMaxThreadCount(200)
        self.is_login_all = False
        self.init_ui()

    def toggle_theme(self, state):
        self.is_dark = bool(state)
        if self.is_dark:
            self.apply_dark_theme()
        else:
            self.apply_light_theme()

    def apply_light_theme(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                color: #000;
            }
            QTableWidget {
                background-color: #ffffff;
                alternate-background-color: #f9f9f9;
            }
            QLabel {
                color: #333;
            }
        """)

    def apply_dark_theme(self):
        self.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                color: #fff;
            }
            QTableWidget {
                background-color: #3c3f41;
                alternate-background-color: #313335;
            }
            QLabel {
                color: #fff;
            }
        """)

    def init_ui(self):
        layout = QVBoxLayout(self)
        top_bar = QHBoxLayout()

        self.toggle = AnimatedToggle()
        self.toggle.stateChanged(self.toggle_theme)

        self.total_label = QLabel("T·ªïng ƒëi·ªÉm: 0 | T·ªïng ACC: 0")
        self.total_label.setFont(QFont("Arial", 12))
        self.total_label.setStyleSheet("color: #333;")

        self.login_all_btn = QPushButton("ƒêƒÉng nh·∫≠p t·∫•t c·∫£")
        self.login_all_btn.clicked.connect(self.login_all_accounts)
        self.login_all_btn.setStyleSheet('''
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #4f8cff, stop:1 #2353ff);
                color: white;
                border-radius: 15px;
                padding: 8px 24px;
                font-size: 15px;
                font-weight: bold;
                border: none;
            }
            QPushButton:hover {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #6faaff, stop:1 #3a6cff);
                color: #fff;
            }
            QPushButton:pressed {
                background: #2353ff;
            }
        ''')

        self.run_all_btn = QPushButton("L√†m Nhi·ªám V·ª• T·∫•t C·∫£")
        self.run_all_btn.clicked.connect(self.run_all_tasks)
        self.run_all_btn.setStyleSheet(self.login_all_btn.styleSheet())

        self.check_proxy_btn = QPushButton("Ki·ªÉm Tra Proxy")
        self.check_proxy_btn.clicked.connect(self.check_proxy_all)
        self.check_proxy_btn.setStyleSheet(self.login_all_btn.styleSheet())

        self.replace_proxy_btn = QPushButton("Thay Proxy Kh√¥ng Ho·∫°t ƒê·ªông")
        self.replace_proxy_btn.clicked.connect(self.replace_dead_proxies)
        self.replace_proxy_btn.setStyleSheet(self.login_all_btn.styleSheet())

        self.get_point_all_btn = QPushButton("L·∫•y ƒëi·ªÉm t·∫•t c·∫£")
        self.get_point_all_btn.clicked.connect(self.get_point_all)
        self.get_point_all_btn.setStyleSheet(self.login_all_btn.styleSheet())

        top_bar.addWidget(self.toggle)
        top_bar.addWidget(self.login_all_btn)
        top_bar.addWidget(self.run_all_btn)
        top_bar.addWidget(self.check_proxy_btn)
        top_bar.addWidget(self.replace_proxy_btn)
        top_bar.addWidget(self.get_point_all_btn)
        top_bar.addStretch()
        top_bar.addWidget(self.total_label)

        self.table = QTableWidget()
        self.table.setColumnCount(8)
        self.table.setHorizontalHeaderLabels([
            "Token", "Proxy", "T√†i kho·∫£n", "M·∫≠t kh·∫©u", "F-ID",
            "ƒêi·ªÉm", "Tr·∫°ng th√°i", "Ghi ch√∫"
        ])
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setAlternatingRowColors(True)
        self.table.setStyleSheet("QTableWidget::item:selected { background-color: #ADD8E6; }")

        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(10)
        shadow.setColor(QColor(0, 0, 0, 160))
        shadow.setOffset(3, 3)
        self.table.setGraphicsEffect(shadow)

        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_context_menu)

        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Interactive)
        self.table.setColumnWidth(0, 50)   # Token
        self.table.setColumnWidth(1, 50)   # Proxy
        self.table.setColumnWidth(2, 120)  # T√†i kho·∫£n
        self.table.setColumnWidth(3, 70)  # M·∫≠t kh·∫©u
        self.table.setColumnWidth(4, 80)   # F-ID
        self.table.setColumnWidth(5, 80)   # ƒêi·ªÉm
        self.table.setColumnWidth(6, 470)  # Tr·∫°ng th√°i (to nh·∫•t)
        self.table.setColumnWidth(7, 250)  # Ghi ch√∫ (b√¨nh th∆∞·ªùng)

        layout.addLayout(top_bar)
        layout.addWidget(self.table)

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_totals)
        self.timer.start(1000)

        self.load_data()
        self.apply_light_theme()

    def show_context_menu(self, pos):
        menu = QMenu()
        login_action = menu.addAction("ƒêƒÉng Nh·∫≠p")
        get_point_action = menu.addAction("L·∫•y ƒëi·ªÉm")
        run_action = menu.addAction("L√†m Nhi·ªám V·ª•")
        # withdraw_action = menu.addAction("R√∫t ƒêi·ªÉm")
        action = menu.exec_(self.table.mapToGlobal(pos))
        if action == login_action:
            self.login_selected_account()
        elif action == get_point_action:
            self.get_point_selected()
        elif action == run_action:
            self.run_selected_task()

    def login_selected_account(self):
        row = self.table.currentRow()
        if row == -1:
            return
        self.is_login_all = False
        account = self.table.item(row, 2).text()
        password = self.password_map.get(row)
        f_id = self.table.item(row, 4).text()
        proxy_string = self.table.item(row, 1).text()
        token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        worker = LoginWorker(row, account, password, f_id, proxy_string, token)
        worker.signals.update_status.connect(self.update_status)
        worker.signals.login_result.connect(self.handle_login_result)
        self.threadpool.start(worker)

    def login_all_accounts(self):
        self.is_login_all = True
        for row in range(self.table.rowCount()):
            account = self.table.item(row, 2).text()
            password = self.password_map.get(row)
            f_id = self.table.item(row, 4).text()
            proxy_string = self.table.item(row, 1).text()
            token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
            worker = LoginWorker(row, account, password, f_id, proxy_string, token)
            worker.signals.update_status.connect(self.update_status)
            worker.signals.login_result.connect(self.handle_login_result)
            self.threadpool.start(worker)

    def update_status(self, row, status):
        self.table.setItem(row, 6, QTableWidgetItem(status))
        print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: {status}")

    def handle_login_result(self, row, token, result, diem):
        if result == "DONE":
            self.table.setItem(row, 0, QTableWidgetItem(token))
            print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: ƒêƒÉng nh·∫≠p th√†nh c√¥ng!")
            # C·∫≠p nh·∫≠t to√†n b·ªô d√≤ng v√†o file ACC.txt
            try:
                acc_file = FILE_PATH
                with open(acc_file, "r", encoding="utf-8") as f:
                    lines = f.readlines()
                if 0 <= row < len(lines):
                    # L·∫•y l·∫°i to√†n b·ªô d·ªØ li·ªáu d√≤ng t·ª´ b·∫£ng
                    new_cells = []
                    for col in range(self.table.columnCount()):
                        item = self.table.item(row, col)
                        new_cells.append(item.text() if item else "")
                    # ƒê·∫£m b·∫£o c√≥ 8 tr∆∞·ªùng
                    if len(new_cells) < 8:
                        new_cells += [""] * (8 - len(new_cells))
                    lines[row] = "|".join(new_cells) + "\n"
                    with open(acc_file, "w", encoding="utf-8") as f:
                        f.writelines(lines)
                    print(f"[LOG] ƒê√£ c·∫≠p nh·∫≠t to√†n b·ªô d√≤ng v√†o file ACC.txt cho d√≤ng {row}")
            except Exception as e:
                print(f"[LOG] L·ªói c·∫≠p nh·∫≠t d√≤ng v√†o file ACC.txt: {e}")
            if not self.is_login_all:
                QMessageBox.information(self, "ƒêƒÉng nh·∫≠p", f"ƒêƒÉng nh·∫≠p th√†nh c√¥ng cho t√†i kho·∫£n {self.table.item(row,2).text()}.")
        elif result == "TOKEN_OK":
            # Token c√≤n s·ªëng, ch·ªâ update ƒëi·ªÉm
            if diem is not None:
                self.table.setItem(row, 5, QTableWidgetItem(str(diem)))
                print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: Token s·ªëng, ƒëi·ªÉm: {diem}")
        elif result == "GET_POINT_OK":
            if diem is not None:
                self.table.setItem(row, 5, QTableWidgetItem(str(diem)))
                print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: L·∫•y ƒëi·ªÉm th√†nh c√¥ng: {diem}")
                # L∆∞u l·∫°i d√≤ng v√†o file ACC.txt
                try:
                    acc_file = FILE_PATH
                    with open(acc_file, "r", encoding="utf-8") as f:
                        lines = f.readlines()
                    if 0 <= row < len(lines):
                        new_cells = []
                        for col in range(self.table.columnCount()):
                            item = self.table.item(row, col)
                            new_cells.append(item.text() if item else "")
                        if len(new_cells) < 8:
                            new_cells += [""] * (8 - len(new_cells))
                        lines[row] = "|".join(new_cells) + "\n"
                        with open(acc_file, "w", encoding="utf-8") as f:
                            f.writelines(lines)
                        print(f"[LOG] ƒê√£ l∆∞u d√≤ng v√†o file ACC.txt sau khi l·∫•y ƒëi·ªÉm cho d√≤ng {row}")
                except Exception as e:
                    print(f"[LOG] L·ªói l∆∞u d√≤ng v√†o file ACC.txt sau khi l·∫•y ƒëi·ªÉm: {e}")
        elif result == "GET_POINT_FAIL":
            print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: L·∫•y ƒëi·ªÉm th·∫•t b·∫°i!")
        else:
            print(f"[LOG] Row {row} - {self.table.item(row,2).text()}: ƒêƒÉng nh·∫≠p th·∫•t b·∫°i!")
            if not self.is_login_all:
                QMessageBox.critical(self, "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i", f"Kh√¥ng th·ªÉ ƒëƒÉng nh·∫≠p t√†i kho·∫£n {self.table.item(row,2).text()}.")

    def update_totals(self):
        total_diem = 0
        for row in range(self.table.rowCount()):
            try:
                total_diem += int(self.table.item(row, 5).text())
            except:
                continue
        self.total_label.setText(f"T·ªïng ƒëi·ªÉm: {total_diem} | T·ªïng ACC: {self.table.rowCount()}")

    def load_data(self):
        if not os.path.exists(FILE_PATH): return
        with open(FILE_PATH, "r", encoding="utf-8") as f:
            lines = f.readlines()
        self.table.setRowCount(len(lines))
        for row, line in enumerate(lines):
            cells = line.strip().split("|")
            while len(cells) < 8:
                cells.append("")
            for col, text in enumerate(cells):
                item = QTableWidgetItem(text)
                item.setTextAlignment(Qt.AlignCenter)
                self.table.setItem(row, col, item)
            self.password_map[row] = cells[3]

    def get_point_selected(self):
        row = self.table.currentRow()
        if row == -1:
            return
        token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        f_id = self.table.item(row, 4).text()
        proxy_string = self.table.item(row, 1).text()
        worker = GetPointWorker(row, token, f_id, proxy_string)
        worker.signals.update_status.connect(self.update_status)
        worker.signals.login_result.connect(self.handle_login_result)
        self.threadpool.start(worker)

    def get_point_all(self):
        for row in range(self.table.rowCount()):
            token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
            f_id = self.table.item(row, 4).text()
            proxy_string = self.table.item(row, 1).text()
            worker = GetPointWorker(row, token, f_id, proxy_string)
            worker.signals.update_status.connect(self.update_status)
            worker.signals.login_result.connect(self.handle_login_result)
            self.threadpool.start(worker)

    def run_selected_task(self):
        row = self.table.currentRow()
        if row == -1:
            return
        threading.Thread(target=self.ChAyAll, args=(row,), daemon=True).start()

    def ChAyAll(self, row):
        try:
            import time
            self.table.setItem(row, 6, QTableWidgetItem(f"B·∫Øt ƒê·∫ßu"))
            self.table.setItem(row, 6, QTableWidgetItem(f"Check Token"))
            chechDangNhap = self.CheckLoginssssss(row)
            print(chechDangNhap)
            if chechDangNhap:
                self.table.setItem(row, 6, QTableWidgetItem(f"B·∫Øt Tr·∫£ L·ªùi C√¢u H·ªèi"))
                self.CheckLuotTraLoiall(row)
                self.table.setItem(row, 6, QTableWidgetItem(f"B·∫Øt Quay Ch·ªØ"))
                self.CheckGhepChuall(row)
                self.table.setItem(row, 6, QTableWidgetItem(f"‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è‚òëÔ∏è"))
            else:
                self.table.setItem(row, 6, QTableWidgetItem(f"[üí©üí©üí©]> Token Ch·∫øt M·∫∏ R·ªìi em!"))
        except Exception as e:
            self.table.setItem(row, 6, QTableWidgetItem(f"[üí©üí©üí©]> L·ªói C√°i Ch√≥ G√¨ √Å T·ª± Check !"))

    def CheckLoginssssss(self, row):
        # Dummy check: token ph·∫£i kh√°c r·ªóng v√† kh√¥ng ph·∫£i 'die' (b·∫°n thay b·∫±ng API check th·∫≠t n·∫øu c√≥)
        token = self.table.item(row, 0).text() if self.table.item(row, 0) else ""
        return bool(token and token.lower() != 'die')

    def CheckLuotTraLoiall(self, selected_row):
        import random, time, requests
        def lay_answer_list():
            if not hasattr(lay_answer_list, "shuffled_answers") or lay_answer_list.index >= len(lay_answer_list.shuffled_answers):
                all_answers = [
                    {"id":"1813068590722039810","submitAnswer":"B"},
                    {"id":"1885293145245704194","submitAnswer":"D"},
                    {"id":"1813055126444163073","submitAnswer":"B"},
                    {"id":"1758663639615070209","submitAnswer":"D"},
                    {"id":"1785300906974543873","submitAnswer":"B"},
                    {"id":"1832001421560930305","submitAnswer":"C"},
                    {"id":"1862969516842795009","submitAnswer":"A"},
                    {"id":"1813061385461415937","submitAnswer":"C"},
                    {"id":"1852195947499892738","submitAnswer":"C"},
                    {"id":"1845597110031245313","submitAnswer":"A"},
                    {"id":"1852198018005479426","submitAnswer":"B"},
                    {"id":"1785310696345862145","submitAnswer":"B"},
                    {"id":"1785286596449697793","submitAnswer":"D"},
                    {"id":"1742430977931452417","submitAnswer":"D"},
                    {"id":"1839964599813079042","submitAnswer":"D"},
                    {"id":"1854143870443585537","submitAnswer":"D"},
                    {"id":"1785518438150995969","submitAnswer":"B"},
                    {"id":"1824048832353558530","submitAnswer":"C"},
                    {"id":"1832922633518604290","submitAnswer":"A"},
                    {"id":"1845605186754994177","submitAnswer":"A"},
                    {"id":"1910234836605042689","submitAnswer":"C"},
                    {"id":"1743642787544043521","submitAnswer":"C"},
                    {"id":"1839623537886142465","submitAnswer":"B"},
                    {"id":"1857079383320297474","submitAnswer":"B"},
                    {"id":"1758729048947089409","submitAnswer":"D"},
                    {"id":"1913734370549690370","submitAnswer":"A"},
                    {"id":"1790399254207328258","submitAnswer":"A"},
                    {"id":"1758658110029225986","submitAnswer":"B"},
                    {"id":"1857079675314675714","submitAnswer":"C"},
                    {"id":"1906204991478239234","submitAnswer":"B"},
                    {"id":"1813068590722039810","submitAnswer":"B"},
                    {"id":"1758661648285360129","submitAnswer":"C"},
                    {"id":"1900874100297801729","submitAnswer":"A"},
                    {"id":"1785309013456879617","submitAnswer":"A"}
                ]
                random.shuffle(all_answers)
                lay_answer_list.shuffled_answers = all_answers
                lay_answer_list.index = 0
            start = lay_answer_list.index
            end = start + 5
            result = lay_answer_list.shuffled_answers[start:end]
            lay_answer_list.index += 5
            return result
        token = self.table.item(selected_row, 0).text()
        proxy = self.table.item(selected_row, 1).text()
        f_id = self.table.item(selected_row, 4).text()
        self.table.setItem(selected_row, 6, QTableWidgetItem("B·∫Øt ƒë·∫ßu ki·ªÉm tra"))
        try:
            proxy_url, port, username, password = proxy.split(':')
            proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
            proxies = {"http": proxy_address, "https": proxy_address}
            headers = {
                "authority": "m.oklavip26.live",
                "accept": "application/json, text/plain, */*",
                "accept-language": "vi-VN,vi;q=0.9",
                "content-type": "application/json",
                "locale": "vi_vn",
                "origin": "https://m.oklavip26.live",
                "priority": "u=1, i",
                "sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
                "sec-ch-ua-mobile": "?0",
                "sec-ch-ua-platform": "Windows",
                "sec-fetch-dest": "empty",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                "f-id": f_id,
                "token": token,
                "cache-control": "no-cache",
                "pragma": "no-cache",
                "referer": "https://m.oklavip26.live/",
            }
            response = requests.get(
                "https://m.oklavip26.live/api/activityQuestion/getActivityQuestionInfo",
                headers=headers, proxies=proxies, timeout=500).json()
            luot = response['data']['surplusNumber']
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"C√≤n {luot} l∆∞·ª£t"))
            for cac in range(int(luot)):
                DanhSachCauHoi = requests.get('https://m.oklavip26.live/api/activityQuestion/getQuestionList',headers=headers, proxies=proxies, timeout=500).json()['data']
                delay_time = random.randint(20, 35)
                for delay in range(delay_time, -1, -1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay}"))
                    time.sleep(1)
                date_time = int(time.time())
                recordNo = requests.get('https://m.oklavip26.live/api/activityQuestion/startAnswerQuestion',headers=headers, proxies=proxies, timeout=500).json()['data']['recordNo']
                dataTraloi = {
                    "answerList": lay_answer_list(),
                    "timeStart": date_time,
                    "recordNo": recordNo
                }
                response = requests.post('https://m.oklavip26.live/api/activityQuestion/submitQuestion',headers=headers,json=dataTraloi, proxies=proxies, timeout=500)
                print(response.json())
                time.sleep(3)
            CheckLuotQuay=requests.get("https://m.oklavip26.live/api/lottery/getLuckyDrawBaseInfo",headers=headers , proxies=proxies , timeout=500).json()
            data2 = {"raffleId": CheckLuotQuay['data']['raffleId']}
            CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/getLuckyDrawInfoByDaily",headers=headers , proxies=proxies , timeout=500).json()['data']['drawCount']
            for xx in range(int(CheckLuotQuay)):
                CheckLuotQuay=requests.post("https://m.oklavip26.live/api/lottery/lotteryByDaily",headers=headers, json=data2 , proxies=proxies , timeout=500).json()
                delay_time = random.randint(5,6)
                for delay in range(delay_time, -1, -1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{CheckLuotQuay}]") )
                    time.sleep(1)
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Xong!"))
        except Exception as e:
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"L·ªói ki·ªÉm tra l∆∞·ª£t: {str(e)}"))

    def CheckGhepChuall(self, selected_row):
        import requests, time
        row = selected_row
        token = self.table.item(row, 0).text()
        proxy = self.table.item(row, 1).text()
        f_id = self.table.item(row, 4).text()
        proxy_url, port, username, password = proxy.split(':')
        proxy_address = f"http://{username}:{password}@{proxy_url}:{port}"
        proxies = {
            "http": proxy_address,
            "https": proxy_address
        }
        headers = {
            "authority": "m.oklavip26.live",
            "accept": "application/json, text/plain, */*",
            "accept-language": "vi-VN,vi;q=0.9",
            "content-type": "application/json",
            "locale": "vi_vn",
            "origin": "https://m.oklavip26.live",
            "priority": "u=1, i",
            "sec-ch-ua": '"Google Chrome";v="129", "Not=A?Brand";v="8", "Chromium";v="129"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "Windows",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-origin",
            "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
            "f-id": f_id,
            "token": token,
            "cache-control": "no-cache",
            "pragma": "no-cache",
            "referer": "https://m.oklavip26.live/",
        }
        try:
            response = requests.get('https://m.oklavip26.live/api/activityCollect/getListAvailable', headers=headers, proxies=proxies, timeout=500).json()
            idGame = response['data'][0]['id']
            data = {"id": idGame}
            draw_response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500).json()
            draw_times = draw_response['data']['drawTimes']
            status_text = f"L∆∞·ª£t gh√©p ch·ªØ c√≤n l·∫°i: {draw_times}"
            self.table.setItem(selected_row, 6, QTableWidgetItem(status_text))
            for _ in range(int(draw_times)):
                response = requests.post('https://m.oklavip26.live/api/activityCollect/drawWord', headers=headers, json=data, proxies=proxies, timeout=500)
                for delay in range(5,-1,-1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response.json()['data']['textName']}]") )
                    time.sleep(1)
            response = requests.post("https://m.oklavip26.live/api/activityCollect/get", headers=headers, json=data, proxies=proxies, timeout=500)
            synthesisTimes = response.json()['data']['synthesisTimes']
            data2 = {"raffleId": requests.get("https://m.oklavip26.live/api/activityCollect/getListAvailable", headers=headers, proxies=proxies, timeout=500).json()['data'][0]['lotteryId']}
            for _ in range(int(synthesisTimes)):
                response = requests.post('https://m.oklavip26.live/api/activityCollect/mergeWord', headers=headers, json=data, proxies=proxies, timeout=500)
                response2 = requests.post('https://m.oklavip26.live/api/lottery/lottery', headers=headers, json=data2, proxies=proxies, timeout=500)
                for delay in range(5,-1,-1):
                    self.table.setItem(selected_row, 6, QTableWidgetItem(f"Delay {delay} [{response2.json()['data']['prizeInfo']['prizeName']}]") )
                    time.sleep(1)
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"Gh√©p Ch·ªØ Ho√†n T·∫•t!"))
        except Exception as e:
            self.table.setItem(selected_row, 6, QTableWidgetItem(f"L·ªói gh√©p ch·ªØ: {str(e)}"))

    def run_all_tasks(self):
        import threading
        for row in range(self.table.rowCount()):
            threading.Thread(target=self.ChAyAll, args=(row,), daemon=True).start()

    def check_proxy_all(self):
        threading.Thread(target=self._check_proxy_thread, daemon=True).start()

    def _check_proxy_thread(self):
        from concurrent.futures import ThreadPoolExecutor, as_completed
        import requests
        from qtpy.QtWidgets import QTableWidgetItem, QDialog, QVBoxLayout, QTextEdit, QLabel, QPushButton
        import time
        proxy_errors = []
        lock = threading.Lock()
        def xu_ly_row(row):
            proxy = self.table.item(row, 1).text()
            self.table.setItem(row, 6, QTableWidgetItem(f"[XXX] Ki·ªÉm Tra M·∫°ng M√°y!"))
            def kiem_tra_mang():
                for lan in range(3):
                    try:
                        requests.get("https://www.google.com", timeout=10)
                        return True
                    except requests.RequestException:
                        self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå M√°y t√≠nh kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng. Th·ª≠ l·∫°i l·∫ßn {lan + 1}"))
                return False
            def kiem_tra_proxy(proxy_str):
                try:
                    ip, port, user, password = proxy_str.split(":")
                    proxy_url = f"http://{user}:{password}@{ip}:{port}"
                    proxies = {"http": proxy_url, "https": proxy_url}
                    response = requests.get("https://geo.myip.link/", proxies=proxies, timeout=10)
                    if response.status_code == 200:
                        return True, response.json()
                    else:
                        return False, f"L·ªói m√£ tr·∫°ng th√°i HTTP: {response.status_code}"
                except Exception as e:
                    return False, str(e)
            if kiem_tra_mang():
                self.table.setItem(row, 6, QTableWidgetItem(f"‚úÖ M·∫°ng ho·∫°t ƒë·ªông."))
                thanh_cong, ket_qua = kiem_tra_proxy(proxy)
                if thanh_cong:
                    self.table.setItem(row, 6, QTableWidgetItem(f"‚úÖ Proxy ho·∫°t ƒë·ªông. "))
                else:
                    self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå Proxy kh√¥ng ho·∫°t ƒë·ªông. "))
                    with lock:
                        proxy_errors.append((row, proxy, ket_qua))
                    # L∆∞u l·∫°i d√≤ng l·ªói v√†o ACC.txt
                    try:
                        acc_file = FILE_PATH
                        with open(acc_file, "r", encoding="utf-8") as f:
                            lines = f.readlines()
                        if 0 <= row < len(lines):
                            new_cells = []
                            for col in range(self.table.columnCount()):
                                item = self.table.item(row, col)
                                new_cells.append(item.text() if item else "")
                            if len(new_cells) < 8:
                                new_cells += [""] * (8 - len(new_cells))
                            lines[row] = "|".join(new_cells) + "\n"
                            with open(acc_file, "w", encoding="utf-8") as f:
                                f.writelines(lines)
                    except Exception as e:
                        print(f"[LOG] L·ªói l∆∞u d√≤ng proxy l·ªói v√†o file ACC.txt: {e}")
            else:
                self.table.setItem(row, 6, QTableWidgetItem(f"‚ùå M√°y t√≠nh kh√¥ng c√≥ k·∫øt n·ªëi m·∫°ng."))
        with ThreadPoolExecutor(max_workers=30) as executor:
            futures = [executor.submit(xu_ly_row, row) for row in range(self.table.rowCount())]
            for future in as_completed(futures):
                pass
        # Hi·ªán popup b√°o proxy l·ªói
        if proxy_errors:
            def show_error_dialog():
                dialog = QDialog(self)
                dialog.setWindowTitle("Danh s√°ch proxy l·ªói")
                layout = QVBoxLayout(dialog)
                label = QLabel(f"T·ªïng s·ªë proxy l·ªói: {len(proxy_errors)}")
                layout.addWidget(label)
                textedit = QTextEdit()
                textedit.setReadOnly(True)
                textedit.setMinimumWidth(400)
                textedit.setMinimumHeight(200)
                textedit.setText("\n".join([f"{row+1}: {proxy} - {err}" for row, proxy, err in proxy_errors]))
                layout.addWidget(textedit)
                btn = QPushButton("ƒê√≥ng")
                btn.clicked.connect(dialog.accept)
                layout.addWidget(btn)
                # CSS ƒë·∫πp cho dialog
                dialog.setStyleSheet('''
                    QDialog {
                        background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #4f8cff, stop:1 #8f5cff);
                        border-radius: 18px;
                    }
                    QLabel {
                        color: white;
                        font-size: 18px;
                        font-weight: bold;
                        padding: 16px 8px 8px 8px;
                    }
                    QPushButton {
                        background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #6faaff, stop:1 #3a6cff);
                        color: white;
                        border-radius: 12px;
                        padding: 8px 24px;
                        font-size: 15px;
                        font-weight: bold;
                        border: none;
                        margin-bottom: 12px;
                    }
                    QPushButton:hover {
                        background: #2353ff;
                    }
                ''')
                dialog.exec_()
            QTimer.singleShot(0, lambda: show_error_dialog())
            # L∆∞u l·∫°i proxy l·ªói cho ch·ª©c nƒÉng thay proxy
            self._last_proxy_errors = proxy_errors
        else:
            self._last_proxy_errors = []

    def replace_dead_proxies(self):
        # T√¨m l·∫°i proxy l·ªói t·ª´ l·∫ßn ki·ªÉm tra g·∫ßn nh·∫•t
        if not hasattr(self, '_last_proxy_errors') or not self._last_proxy_errors:
            QMessageBox.information(self, "Th√¥ng b√°o", "B·∫°n c·∫ßn ki·ªÉm tra proxy tr∆∞·ªõc khi thay proxy l·ªói!")
            return
        from qtpy.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QLabel, QPushButton
        proxy_errors = self._last_proxy_errors
        dialog = QDialog(self)
        dialog.setWindowTitle("Thay Proxy Kh√¥ng Ho·∫°t ƒê·ªông")
        layout = QVBoxLayout(dialog)
        label = QLabel(f"Nh·∫≠p {len(proxy_errors)} proxy m·ªõi, m·ªói proxy 1 d√≤ng, ƒë√∫ng th·ª© t·ª±:")
        layout.addWidget(label)
        textedit = QTextEdit()
        textedit.setMinimumWidth(400)
        textedit.setMinimumHeight(200)
        layout.addWidget(textedit)
        btn = QPushButton("Thay th·∫ø")
        layout.addWidget(btn)
        def on_replace():
            new_proxies = [line.strip() for line in textedit.toPlainText().splitlines() if line.strip()]
            if len(new_proxies) != len(proxy_errors):
                QMessageBox.warning(dialog, "L·ªói", f"B·∫°n ph·∫£i nh·∫≠p ƒë√∫ng {len(proxy_errors)} proxy!")
                return
            # Thay v√†o b·∫£ng v√† file ACC.txt
            acc_file = FILE_PATH
            with open(acc_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
            for idx, (row, old_proxy, err) in enumerate(proxy_errors):
                proxy = new_proxies[idx]
                # Update b·∫£ng
                self.table.setItem(row, 1, QTableWidgetItem(proxy))
                # Update file
                if 0 <= row < len(lines):
                    cells = lines[row].strip().split("|")
                    if len(cells) < 8:
                        cells += [""] * (8 - len(cells))
                    cells[1] = proxy
                    lines[row] = "|".join(cells) + "\n"
            with open(acc_file, "w", encoding="utf-8") as f:
                f.writelines(lines)
            QMessageBox.information(dialog, "Th√†nh c√¥ng", "ƒê√£ thay proxy m·ªõi cho c√°c d√≤ng l·ªói!")
            dialog.accept()
        btn.clicked.connect(on_replace)
        dialog.exec_()

class GetPointWorker(QRunnable):
    def __init__(self, row, token, f_id, proxy_string):
        super().__init__()
        self.row = row
        self.token = token
        self.f_id = f_id
        self.proxy_string = proxy_string
        self.signals = LoginSignals()

    def create_proxy(self, proxy_string):
        parts = proxy_string.split(":")
        ip = parts[0]
        port = parts[1]
        username = parts[2]
        password = parts[3]
        proxies = {
            "http": f"http://{username}:{password}@{ip}:{port}",
            "https": f"http://{username}:{password}@{ip}:{port}"
        }
        return proxies

    def run(self):
        import requests
        proxies = self.create_proxy(self.proxy_string)
        try:
            headers = {
                "authority": "m.oklavip26.live",
                "accept": "application/json, text/plain, */*",
                "accept-language": "vi-VN,vi;q=0.9",
                "content-type": "application/json",
                "locale": "vi_vn",
                "referer": "https://m.oklavip26.live/personal",
                "sec-ch-ua-platform": "Windows",
                "sec-fetch-mode": "cors",
                "sec-fetch-site": "same-origin",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) coc_coc_browser/114.0.144 Chrome/114.0.0.0 Safari/537.36",
                "f-id": self.f_id,
                "token": self.token,
            }
            responsediem = requests.get("https://m.oklavip26.live/api/wallet/getWallet", headers=headers, proxies=proxies, timeout=20).json()
            print(responsediem)
            diem = responsediem['data']['integral']
            self.signals.update_status.emit(self.row, f"L·∫•y ƒëi·ªÉm th√†nh c√¥ng: {diem}")
            self.signals.login_result.emit(self.row, self.token, "GET_POINT_OK", diem)
        except Exception as e:
            print(f"GetPointWorker Exception: {e}")
            self.signals.update_status.emit(self.row, "L·∫•y ƒëi·ªÉm th·∫•t b·∫°i!")
            self.signals.login_result.emit(self.row, self.token, "GET_POINT_FAIL", None)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    from qtpy.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton
    def show_notice():
        dialog = QDialog()
        dialog.setWindowTitle("Th√¥ng b√°o")
        layout = QVBoxLayout(dialog)
        label = QLabel("Tool ƒëang trong qu√° tr√¨nh ho√†n thi·ªán s·∫Ω ƒë·∫ßy ƒë·ªß ch·ª©c nƒÉng")
        label.setWordWrap(True)
        layout.addWidget(label)
        btn = QPushButton("ƒê√≥ng")
        btn.clicked.connect(dialog.accept)
        layout.addWidget(btn)
        # CSS ƒë·∫πp cho dialog
        dialog.setStyleSheet('''
            QDialog {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #4f8cff, stop:1 #8f5cff);
                border-radius: 18px;
            }
            QLabel {
                color: white;
                font-size: 18px;
                font-weight: bold;
                padding: 16px 8px 8px 8px;
            }
            QPushButton {
                background: qlineargradient(x1:0, y1:0, x2:1, y2:0, stop:0 #6faaff, stop:1 #3a6cff);
                color: white;
                border-radius: 12px;
                padding: 8px 24px;
                font-size: 15px;
                font-weight: bold;
                border: none;
                margin-bottom: 12px;
            }
            QPushButton:hover {
                background: #2353ff;
            }
        ''')
        dialog.exec_()
    QTimer.singleShot(0, show_notice)
    win = Table3D()
    win.show()
    sys.exit(app.exec())
